// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: 'https://hosted.mender.io/' | (string & {});
};

/**
 * Error descriptor.
 */
export type _Error = {
  /**
   * Description of the error.
   */
  error: string;
  /**
   * Request ID (same as in X-MEN-RequestID header).
   */
  request_id?: string;
};

/**
 * URL for artifact file download.
 */
export type ArtifactLink = {
  uri: string;
  expire: string;
};

export type JobStatus = {
  id?: string;
  workflowName?: string;
  inputParameters?: Array<InputParameter>;
  status?: string;
  results?: Array<TaskResult>;
};

export type InputParameter = {
  name: string;
  value: string;
};

export type TaskResult = {
  success?: boolean;
  cli?: TaskResultCli;
  request?: TaskResultHttpRequest;
  response?: TaskResultHttpResponse;
};

export type TaskResultCli = {
  command?: Array<string>;
  output?: string;
  error?: string;
  exitCode?: number;
};

export type TaskResultHttpRequest = {
  statusCode?: number;
  body?: string;
};

export type TaskResultHttpResponse = {
  uri?: string;
  method?: string;
  headers?: Array<string>;
  body?: string;
};

export type TenantNew = {
  /**
   * ID of new tenant.
   */
  tenant_id: string;
};

/**
 * Device identity attributes, in the form of a JSON structure. The attributes are completely vendor-specific, the provided ones are just an example. In reference implementation structure contains vendor-selected fields, such as MACs, serial numbers, etc.
 */
export type IdentityData = {
  /**
   * MAC address.
   */
  mac?: string;
  /**
   * Stock keeping unit.
   */
  sku?: string;
  /**
   * Serial number.
   */
  sn?: string;
};

/**
 * AuthSet describes the identity a device uses to authenticate with the Mender server.
 */
export type AuthSet = {
  /**
   * The unique ID of the authentication set.
   */
  id?: string;
  /**
   * The unique ID of the device the authentication set belongs.
   */
  device_id?: string;
  identity_data?: IdentityData;
  /**
   * The device's public key (PEM encoding). generated by the device or pre-provisioned by the vendor. Currently supported public algorithms are: RSA, Ed25519 and ECDSA P-256.
   */
  pubkey?: string;
  /**
   * A device tier.
   */
  tier?: 'standard' | 'micro' | 'system';
  /**
   * Authorization status of the set.
   */
  status?: string;
  /**
   * The creation timestamp of the authentication set.
   */
  ts?: string;
};

export type ProvisionDevice = {
  /**
   * ID of the new device.
   */
  device_id: string;
};

/**
 * The scope of the attribute.
 *
 * Scope is a string and acts as namespace for the attribute name.
 *
 * * __inventory__: Attributes reported by the device.
 * * __system__: Attributes populated by the mender-server.
 * * __identity__: Device's identity attributes provided in the device's auth request.
 * * __monitor__: Attributes populated by the monitoring add-on.
 * * __tags__: User-defined attributes associated with the device.
 *
 */
export const Scope = {
  SYSTEM: 'system',
  IDENTITY: 'identity',
  INVENTORY: 'inventory',
  MONITOR: 'monitor',
  TAGS: 'tags'
} as const;

/**
 * The scope of the attribute.
 *
 * Scope is a string and acts as namespace for the attribute name.
 *
 * * __inventory__: Attributes reported by the device.
 * * __system__: Attributes populated by the mender-server.
 * * __identity__: Device's identity attributes provided in the device's auth request.
 * * __monitor__: Attributes populated by the monitoring add-on.
 * * __tags__: User-defined attributes associated with the device.
 *
 */
export type Scope = (typeof Scope)[keyof typeof Scope];

/**
 * The actor may be a user or device.
 * Depending on the type of the actor different information will be available.
 *
 */
export type Actor = {
  /**
   * A unique identifier of the actor.
   *
   */
  id: string;
  /**
   * The type of the actor.
   *
   */
  type: 'user' | 'device';
  /**
   * The email address of the user.
   *
   */
  email?: string;
  /**
   * The identity data of the device.
   *
   */
  identity_data?: string;
};

/**
 * The tenant descriptor.
 */
export type AuditlogsTenant = {
  /**
   * The id of a tenant.
   */
  id: string;
  /**
   * The name of a tenant.
   */
  name?: string;
  /**
   * The id of a parent tenant.
   */
  parent?: string;
};

/**
 * User descriptor.
 */
export type AuditlogsUser = {
  /**
   * Email address of the user.
   */
  email: string;
};

/**
 * The deployment descriptor.
 */
export type Deployment = {
  name: string;
  artifact_name: string;
};

/**
 * The artifact descriptor.
 */
export type AuditlogsArtifact = {
  name: string;
};

/**
 * Device descriptor.
 */
export type AuditlogsDevice = {
  /**
   * Device ID.
   */
  id?: string;
  /**
   * Vendor-specific JSON representation of the device identity data (MACs, serial numbers, etc.).
   */
  identity_data: string;
};

/**
 * Various types of objects are supported.
 * Depending on the type of object different information will be available.
 *
 */
export type _Object = {
  /**
   * A unique identifier of the object.
   *
   */
  id: string;
  /**
   * The type of the object.
   *
   */
  type: 'tenant' | 'user' | 'deployment' | 'artifact' | 'device';
  tenant?: AuditlogsTenant;
  user?: AuditlogsUser;
  deployment?: Deployment;
  artifact?: AuditlogsArtifact;
  device?: AuditlogsDevice;
};

/**
 * Audit log entry
 */
export type AuditLog = {
  actor: Actor;
  time: string;
  action:
    | 'create'
    | 'update'
    | 'delete'
    | 'abort'
    | 'reject'
    | 'decommission'
    | 'open_terminal'
    | 'close_terminal'
    | 'open_portforward'
    | 'close_portforward'
    | 'download_file'
    | 'upload_file'
    | 'set_configuration'
    | 'deploy_configuration'
    | 'upload';
  object: _Object;
  change?: string;
};

/**
 * Detailed artifact.
 */
export type Artifact = {
  id: string;
  name: string;
  description?: string;
  /**
   * An array of compatible device types.
   */
  device_types_compatible: Array<string>;
  info?: ArtifactInfo;
  /**
   * Idicates if artifact is signed or not.
   */
  signed?: boolean;
  updates?: Array<Update>;
  /**
   * List of Artifact provides.
   *
   * Map of key/value pairs, where both keys and values are strings.
   *
   */
  artifact_provides?: {
    [key: string]: string;
  };
  /**
   * List of Artifact depends.
   *
   * Map of key/value pairs, where keys are strings and values are lists of strings.
   *
   */
  artifact_depends?: {
    [key: string]: Array<string>;
  };
  /**
   * List of Clear Artifact provides.
   */
  clears_artifact_provides?: Array<string>;
  /**
   * Artifact total size in bytes - the size of the actual file that will be transferred to the device (compressed).
   *
   */
  size?: number;
  /**
   * Represents creation / last edition of any of the artifact properties.
   *
   */
  modified: string;
};

export type DeploymentStatus = {
  status:
    | 'installing'
    | 'pause_before_installing'
    | 'downloading'
    | 'pause_before_rebooting'
    | 'rebooting'
    | 'pause_before_committing'
    | 'success'
    | 'failure'
    | 'already-installed';
  /**
   * Additional state information
   */
  substate?: string;
};

export type DeploymentInstructions = {
  /**
   * Deployment ID
   */
  id: string;
  artifact: DeploymentInstructionsArtifact;
} | null;

export type DeploymentLog = {
  /**
   * Array of log entries of a deployment
   */
  messages: Array<DeploymentLogMessagesInner>;
};

export type CheckUpdateDependsRequest = {
  /**
   * Device type of the device.
   */
  device_type: string;
  /**
   * Name of the currently installed artifact.
   */
  artifact_name: string;
  [key: string]: string;
};

export type DeploymentInstructionsArtifactSource = {
  /**
   * URL to fetch the artifact from
   */
  uri?: string;
  /**
   * URL expiration time
   */
  expire?: string;
};

export type DeploymentInstructionsArtifact = {
  id?: string;
  source: DeploymentInstructionsArtifactSource;
  /**
   * Compatible device types
   */
  device_types_compatible: Array<string>;
  artifact_name: string;
};

export type DeploymentLogMessagesInner = {
  timestamp: string;
  level: string;
  message: string;
};

/**
 * Information about artifact format and version.
 */
export type ArtifactInfo = {
  format?: string;
  version?: number;
};

/**
 * Information about update type.
 *
 */
export type ArtifactTypeInfo = {
  /**
   * Note that for emtpy Artifacts, the type is 'null'
   */
  type?: string;
};

/**
 * Information about particular update file.
 *
 */
export type UpdateFile = {
  name?: string;
  checksum?: string;
  size?: number;
  date?: string;
};

/**
 * metadata is an object of unknown structure as this is dependent of update type (also custom defined by user)
 */
export type MetadataAny = {
  [key: string]: string;
};

/**
 * Deprecated: Please use `metadata` instead.
 * A list of objects of unknown structure as this is dependent
 * of update type (also custom defined by user)
 *
 *
 * @deprecated
 */
export type MetadataAnyDeprecated = Array<{
  [key: string]: unknown;
}>;

/**
 * Single updated to be applied.
 *
 */
export type Update = {
  type_info?: ArtifactTypeInfo;
  files?: Array<UpdateFile>;
  metadata?: MetadataAny;
  meta_data?: MetadataAnyDeprecated;
};

export type DeploymentInstructionsArtifactSourceV2 = {
  /**
   * URL to fetch the artifact from
   */
  uri?: string;
  /**
   * URL expiration time
   */
  expire?: string;
};

export type DeploymentInstructionsArtifactV2 = {
  id?: string;
  source: DeploymentInstructionsArtifactSourceV2;
  /**
   * Compatible device types
   */
  device_types_compatible: Array<string>;
  artifact_name: string;
};

export type DeploymentInstructionsV2 = {
  /**
   * Deployment ID (device unique)
   */
  id: string;
  artifact: DeploymentInstructionsArtifactV2;
  /**
   * A valid JSON object defining the update control map.
   * The ID attribute is automatically set to the deployment's ID.
   * *NOTE*: Available only in the Enterprise plan.
   *
   */
  update_control_map?: {
    [key: string]: unknown;
  };
};

/**
 * A valid JSON object defining the update control map.
 * The ID attribute is automatically set to the deployment's ID.
 * *NOTE*: Available only in the Enterprise plan.
 *
 */
export type UpdateControlMap = {
  [key: string]: unknown;
};

export type CheckUpdateRequest = {
  /**
   * Key-value map of strings which describes the artifact(s) installed on the device and the
   * device itself. It is used to determine the next deployment. The keys device_type and
   * artifact_name are mandatory, additional free-form key-value pairs can be specified.
   *
   */
  device_provides: {
    [key: string]: string;
  };
  /**
   * True if the device supports Update Control Maps.
   * *NOTE*: Available only in the Enterprise plan.
   *
   */
  update_control_map?: boolean;
};

/**
 * Per tenant storage settings.
 */
export type StorageSettings = {
  /**
   * The storage provider type 'azure' Blob storage or AWS 's3' (defaults to s3).
   */
  type?: 's3' | 'azure';
  /**
   * AWS region (S3 only: required).
   */
  region?: string;
  /**
   * S3 Bucket (Azure: container) name.
   */
  bucket: string;
  /**
   * Bucket/container endpoint URI.
   */
  uri?: string;
  /**
   * Public Endpoint URI for presigning URLs (S3 only).
   */
  external_uri?: string;
  /**
   * Access key identifier (Azure: account name).
   */
  key: string;
  /**
   * Secret access key (Azure: access key).
   */
  secret: string;
  /**
   * AWS S3 session token (S3 only).
   */
  token?: string;
  /**
   * Force S3 path-style instead of virtual-hosted style (S3 only).
   */
  force_path_style?: boolean;
  /**
   * Enable S3 Transfer acceleration (S3 only).
   */
  use_accelerate?: boolean;
  /**
   * Shared access key connection string (Azure only).
   */
  connection_string?: string;
  /**
   * Alias for 'bucket' (Azure only).
   */
  container_name?: string;
  /**
   * Alias for 'key' (Azure only).
   */
  account_name?: string;
  /**
   * Alias for 'secret' (Azure only).
   */
  account_key?: string;
};

/**
 * Tenant account storage limit and storage usage.
 */
export type StorageUsage = {
  /**
   * Storage limit in bytes. If set to 0 - there is no limit for storage.
   *
   */
  limit: number;
  /**
   * Current storage usage in bytes.
   *
   */
  usage: number;
};

export type DeploymentV1Internal = {
  created: string;
  name: string;
  artifact_name: string;
  id: string;
  finished?: string;
  status: 'inprogress' | 'pending' | 'finished';
  device_count?: number;
  /**
   * An array of artifact's identifiers.
   */
  artifacts?: Array<string>;
  type?: 'configuration' | 'software';
};

export type ConfigurationDeploymentRequest = {
  /**
   * Name of the deployment
   */
  name: string;
  /**
   * A string containing a configuration object.
   * The deployments service will use it to generate configuration
   * artifact for the device.
   * The artifact will be generated when the device will ask
   * for an update.
   *
   */
  configuration: string;
  /**
   * The number of times a device can retry the deployment
   * in case of failure, defaults to 0.
   *
   */
  retries?: number;
  /**
   * A valid JSON object defining the update control map.
   * *NOTE*: Available only in the Enterprise plan.
   *
   */
  update_control_map?: {
    [key: string]: unknown;
  };
};

/**
 * Status of the generate delta job.
 */
export type GenerateDeltaJobStatus = {
  status?: string;
};

export type DeviceDeployment = {
  id?: string;
  deployment: DeploymentV1Internal;
  device: DeviceWithImage;
};

export type LastDeviceDeploymentsStatuses = {
  device_deployment_last_statuses: Array<LastDeviceDeployment>;
};

export type LastDeviceDeployment = {
  device_id?: string;
  deployment_id?: string;
  device_deployment_id?: string;
  device_deployment_status?: string;
};

export type LastDeviceDeploymentReq = {
  device_ids: Array<string>;
};

export type GetBinaryDeltaConfigurations200ResponseInner = {
  /**
   * Tenant ID
   */
  tenant_id?: string;
  /**
   * Flag indicating if binary delta generation is enabled
   */
  enabled?: boolean;
};

export type UploadArtifactRequest = {
  /**
   * Artifact ID, optional; the server generates a randome one if not provided.
   */
  artifact_id?: string;
  /**
   * Size of the artifact file in bytes.
   */
  size?: number;
  description?: string;
  /**
   * Artifact. It has to be the last part of request.
   */
  artifact: Blob | File;
};

/**
 * Device's groups names.
 */
export type DeviceGroups = {
  /**
   * List of group names for the device.
   */
  groups?: Array<string>;
};

/**
 * Tenant account storage limit and storage usage.
 */
export type StorageLimit = {
  /**
   * Storage limit in bytes. If set to 0 - there is no limit for storage.
   *
   */
  limit: number;
  /**
   * Current storage usage in bytes.
   *
   */
  usage: number;
};

export const DeviceStatus = {
  FAILURE: 'failure',
  ABORTED: 'aborted',
  PAUSE_BEFORE_INSTALLING: 'pause_before_installing',
  PAUSE_BEFORE_COMMITTING: 'pause_before_committing',
  PAUSE_BEFORE_REBOOTING: 'pause_before_rebooting',
  DOWNLOADING: 'downloading',
  INSTALLING: 'installing',
  REBOOTING: 'rebooting',
  PENDING: 'pending',
  SUCCESS: 'success',
  NOARTIFACT: 'noartifact',
  ALREADY_INSTALLED: 'already-installed',
  DECOMMISSIONED: 'decommissioned'
} as const;

export type DeviceStatus = (typeof DeviceStatus)[keyof typeof DeviceStatus];

export type DeviceWithImageImageMeta = {
  /**
   * Image description
   */
  description?: string;
};

export type DeviceWithImageImageMetaArtifact = {
  name?: string;
  /**
   * An array of compatible device types.
   */
  device_types_compatible?: Array<string>;
  info?: ArtifactInfo;
  /**
   * Idicates if artifact is signed or not.
   */
  signed?: boolean;
  updates?: Array<Update>;
  /**
   * List of Artifact provides.
   *
   * Map of key/value pairs, where both keys and values are strings.
   *
   */
  artifact_provides?: {
    [key: string]: string;
  };
  /**
   * List of Artifact depends.
   *
   * Map of key/value pairs, where keys are strings and values are lists of strings.
   *
   */
  artifact_depends?: {
    [key: string]: Array<string>;
  };
  /**
   * List of Clear Artifact provides.
   */
  clears_artifact_provides?: Array<string>;
};

export type DeviceWithImageImage = {
  /**
   * Image ID
   */
  id?: string;
  meta?: DeviceWithImageImageMeta;
  meta_artifact?: DeviceWithImageImageMetaArtifact;
  /**
   * Image size in bytes
   */
  size?: number;
  /**
   * Creation / last edition of any of the artifact properties
   */
  modified?: string;
};

export type DeviceWithImage = {
  /**
   * Device identifier.
   */
  id: string;
  status: DeviceStatus;
  created?: string;
  started?: string;
  finished?: string;
  deleted?: string;
  device_type?: string;
  /**
   * Availability of the device's deployment log.
   */
  log: boolean;
  /**
   * State reported by device
   */
  state?: string;
  /**
   * Additional state information
   */
  substate?: string;
  /**
   * Number of deployment attempts for this device
   */
  attempts?: number;
  image?: DeviceWithImageImage;
};

/**
 * xdelta3 arguments. Please refer to the xdelta3 documentation
 * for a detailed description of the different options.
 *
 */
export type XDeltaArgs = {
  /**
   * Disables checksum
   *
   */
  disable_checksum?: boolean;
  /**
   * Disable external decompression
   *
   */
  disable_external_decompression?: boolean;
  /**
   * Compression level
   *
   */
  compression_level?: number;
  /**
   * Source window size
   *
   */
  source_window_size?: number;
  /**
   * Input window size
   *
   */
  input_window_size?: number;
  /**
   * Compression duplicates window
   *
   */
  compression_duplicates_window?: number;
  /**
   * Instruction buffer size
   *
   */
  instruction_buffer_size?: number;
};

/**
 * The mender-binary-delta-generator configuration options.
 */
export type BinaryDeltaConfiguration = {
  xdelta_args?: XDeltaArgs;
  /**
   * Delta generation job timeout in seconds.
   *
   */
  timeout?: number;
};

/**
 * Limit descriptor.
 */
export type Limit = {
  /**
   * Minimum value.
   */
  min?: number;
  /**
   * Maximum value.
   */
  max?: number;
  /**
   * Default value.
   */
  default?: number;
};

/**
 * Limits for arguments which will be passed to xdelta3.
 * Please refer to the xdelta3 documentation
 * for a detailed description of the different options.
 *
 */
export type XDeltaArgsLimits = {
  /**
   * Limit for compression level.
   */
  compression_level?: Limit;
  /**
   * Limit for source window size.
   */
  source_window_size?: Limit;
  /**
   * Limit for input window size limit.
   */
  input_window_size?: Limit;
  /**
   * Limit for compression duplicates window.
   */
  compression_duplicates_window?: Limit;
  /**
   * Limit for instruction buffer size.
   */
  instruction_buffer_size?: Limit;
};

/**
 * The mender-binary-delta-generator configuration limits.
 */
export type BinaryDeltaLimits = {
  xdelta_args_limits?: XDeltaArgsLimits;
  timeout?: Limit;
  /**
   * Maximum number of delta generation jobs which can be run in parallel.
   *
   */
  jobs_in_parallel?: Limit;
  /**
   * Maximum number of queued delta generation jobs.
   *
   */
  queue_length?: Limit;
};

/**
 * Delta configuration options.
 */
export type DeltaConfiguration = {
  enabled?: boolean;
  binary_delta?: BinaryDeltaConfiguration;
  binary_delta_limits?: BinaryDeltaLimits;
};

/**
 * Configuration.
 */
export type ConfigurationTenant = {
  delta?: DeltaConfiguration;
};

/**
 * Error descriptor with additional metadata.
 */
export type ErrorExt = {
  /**
   * Description of the error.
   */
  error: string;
  /**
   * Request ID (same as in X-MEN-RequestID header).
   */
  request_id?: string;
  metadata?: {
    [key: string]: unknown;
  };
};

export type NewDeployment = {
  /**
   * Name of the deployment
   */
  name: string;
  /**
   * Name of the artifact to deploy
   */
  artifact_name: string;
  /**
   * An array of devices' identifiers.
   */
  devices?: Array<string>;
  /**
   * When set, the deployment will be created for all
   * currently accepted devices.
   *
   */
  all_devices?: boolean;
  /**
   * Force the installation of the Artifact disabling the `already-installed` check.
   */
  force_installation?: boolean;
  phases?: Array<NewDeploymentPhase>;
  /**
   * The number of times a device can retry the deployment in case of failure, defaults to 0
   */
  retries?: number;
  /**
   * A valid JSON object defining the update control map.
   * *NOTE*: Available only in the Enterprise plan.
   *
   */
  update_control_map?: {
    [key: string]: unknown;
  };
  /**
   * The flag idicating if the autogeneration of delta artifacts is enabled for a given deployment.
   *
   */
  autogenerate_delta?: boolean;
};

export type NewDeploymentForGroup = {
  /**
   * Name of the deployment
   */
  name: string;
  /**
   * Name of the artifact to deploy
   */
  artifact_name: string;
  /**
   * Force the installation of the Artifact disabling the `already-installed` check.
   */
  force_installation?: boolean;
  phases?: Array<NewDeploymentPhase>;
  /**
   * The number of times a device can retry the deployment in case of failure, defaults to 0
   */
  retries?: number;
  /**
   * A valid JSON object defining the update control map.
   * *NOTE*: Available only in the Enterprise plan.
   *
   */
  update_control_map?: {
    [key: string]: unknown;
  };
  /**
   * The flag idicating if the autogeneration of delta artifacts is enabled for a given deployment.
   *
   */
  autogenerate_delta?: boolean;
};

export type DeploymentV1 = {
  /**
   * Deployment identifier
   */
  id: string;
  /**
   * Name of the deployment
   */
  name: string;
  /**
   * Name of the artifact to deploy
   */
  artifact_name: string;
  /**
   * Deployment's creation date and time
   */
  created: string;
  /**
   * Deployment's completion date and time
   */
  finished?: string;
  /**
   * Status of the deployment
   */
  status: 'inprogress' | 'scheduled' | 'pending' | 'finished';
  /**
   * Number of devices the deployment acted upon
   */
  device_count: number;
  /**
   * An array of artifact's identifiers.
   */
  artifacts?: Array<string>;
  /**
   * An array of groups the devices targeted by the deployment belong to.
   * Available only if the user created the deployment for a group or a single device (if the device was in a static group).
   *
   */
  groups?: Array<string>;
  /**
   * An array of deployments phases (if any were defined for the deployment).
   */
  phases?: Array<DeploymentPhase>;
  /**
   * The number of times a device can retry the deployment in case of failure, defaults to 0
   */
  retries?: number;
  /**
   * A valid JSON object defining the update control map.
   * *NOTE*: Available only in the Enterprise plan.
   *
   */
  update_control_map?: {
    [key: string]: unknown;
  };
  /**
   * max_devices denotes a limit on a number of completed deployments (failed or successful) above which the dynamic deployment will be finished.
   *
   */
  max_devices?: number;
  /**
   * In case of dynamic deployments this is a number of devices targeted initially (maching the filter at the moment of deployment creation).
   *
   */
  initial_device_count?: number;
  /**
   * Flag indicating if the deployment is dynamic or not.
   *
   */
  dynamic?: boolean;
  type?: 'configuration' | 'software';
  /**
   * A string containing a configuration object provided
   * with the deployment constructor.
   *
   */
  configuration?: string;
  /**
   * The flag idicating if the autogeneration of delta artifacts is enabled for a given deployment.
   *
   */
  autogenerate_delta?: boolean;
  statistics?: DeploymentStatistics;
  filter?: FilterV1;
};

/**
 * An array of deployments phases. Phases define a starting point and
 * a relative batch size of devices to which the deployment applies.
 *
 * A single phase allows scheduling a deployment to start at a specific
 * time.
 *
 * Multiple phases split the deployment into smaller batches of devices
 * at the time giving a higher level of control of the rate devices are
 * updated.
 *
 * *NOTE*: Professional plan is only allowed to specify a single phase to
 * schedule deployments, this feature is not available for Starter plan.
 *
 */
export type NewDeploymentPhase = {
  /**
   * Percentage of devices to update in the phase.
   * This field is optional for the last phase.
   * The last phase will contain the rest of the devices.
   * Note that if the percentage of devices entered does not
   * add up to a whole number of devices it is rounded down,
   * and in the case it is rounded down to zero, a 400 error
   * will be returned. This is mostly a concern when the deployment
   * consists of a low number of devices, like say 5 percent of 11
   * devices will round to zero, and an error is returned by the server.
   *
   */
  batch_size?: number;
  /**
   * Start date of a phase.
   * Can be skipped for the first phase of a new deployment definition ('start immediately').
   *
   */
  start_ts?: string;
};

export type DeviceDeploymentV1 = {
  id?: string;
  deployment: DeploymentV1;
  device: DeviceWithImage;
};

/**
 * Artifact information update.
 */
export type ArtifactUpdateV1 = {
  description?: string;
};

/**
 * Detailed artifact.
 */
export type ArtifactV1 = {
  id: string;
  name: string;
  description?: string;
  /**
   * An array of compatible device types.
   */
  device_types_compatible: Array<string>;
  info?: ArtifactInfo;
  /**
   * Idicates if artifact is signed or not.
   */
  signed?: boolean;
  updates?: Array<Update>;
  /**
   * List of Artifact provides.
   *
   * Map of key/value pairs, where both keys and values are strings.
   *
   */
  artifact_provides?: {
    [key: string]: string;
  };
  /**
   * List of Artifact depends.
   *
   * Map of key/value pairs, where keys are strings and values are lists of strings.
   *
   */
  artifact_depends?: {
    [key: string]: Array<string>;
  };
  /**
   * List of Clear Artifact provides.
   */
  clears_artifact_provides?: Array<string>;
  /**
   * Artifact total size in bytes - the size of the actual file that will be transferred to the device (compressed).
   *
   */
  size?: number;
  /**
   * Represents creation / last edition of any of the artifact properties.
   *
   */
  modified: string;
};

/**
 * URL for artifact file upload.
 */
export type ArtifactUploadLink = {
  /**
   * The ID of the artifact upload intent.
   */
  id: string;
  uri: string;
  expire: string;
};

/**
 * List of releases
 */
export type ReleasesV1 = Array<ReleaseV1>;

/**
 * Groups artifacts with the same release name into a single resource.
 */
export type ReleaseV1 = {
  /**
   * release name.
   *
   */
  Name?: string;
  /**
   * Last modification time for the release.
   *
   */
  modified?: string;
  /**
   * List of artifacts for this release.
   */
  Artifacts?: Array<ArtifactV1>;
  /**
   * Number of artifacts.
   */
  ArtifactsCount?: number;
  /**
   * Tags assigned to the release used for filtering releases. Each tag
   * must be valid a ASCII string and contain only lowercase and uppercase
   * letters, digits, underscores, periods and hyphens.
   */
  tags?: Array<string>;
  /**
   * Additional information describing a Release limited to 1024 characters. Please use the v2 API to set this field.
   *
   */
  notes?: string;
};

/**
 * The mender-binary-delta-generator configuration options.
 */
export type BinaryDeltaConfigurationUpdate = {
  xdelta_args?: XDeltaArgs;
};

/**
 * Artifact metadata
 */
export type DirectUploadMetadata = {
  /**
   * wsize of the artifact file.
   *
   */
  size?: number;
  /**
   * List of updates for this artifact.
   */
  updates?: Array<Update>;
};

/**
 * Deployment identifier
 */
export type DeploymentIdentifier = {
  deployment_ids?: Array<string>;
};

/**
 * Filter built based on devices targeted by the deployment.
 *
 */
export type FilterV1 = {
  /**
   * Unique identifier of the saved filter.
   *
   */
  id?: string;
  /**
   * Name of the saved filter.
   *
   */
  name?: string;
  terms: Array<AttributeFilterPredicate>;
};

export type DeploymentStatusStatisticsList200ResponseInner = {
  /**
   * The deployment ID
   */
  id?: string;
  stats?: Statistics;
};

/**
 * Update control map.
 */
export type PatchDeploymentControlMapRequest = {
  update_control_map?: {
    [key: string]: unknown;
  };
};

export type AbortDeploymentRequest = {
  status: 'aborted';
};

export type UploadArtifactRequest2 = {
  /**
   * Size of the artifact file in bytes.
   * DEPRECATED: _since Mon Apr 6 2020_ Size is determined from uploaded content.
   *
   */
  size?: number;
  description?: string;
  /**
   * Artifact. It has to be the last part of request.
   */
  artifact: Blob | File;
};

export type CompleteDirectUpload404Response = {
  error?: string;
  /**
   * Request identifier (Header: X-Men-Requestid)
   */
  request_id?: string;
};

export type GenerateArtifactRequest = {
  /**
   * Name of the artifact to generate.
   */
  name: string;
  /**
   * Description of the artifact to generate.
   */
  description?: string;
  /**
   * An array of compatible device types.
   */
  device_types_compatible: Array<string>;
  /**
   * Update Module used to generate the artifact.
   */
  type: 'single_file';
  /**
   * String that represents a JSON document defining the arguments used to generate the artifact.
   * The service won't parse the content of this parameter and pass it as it is to the create artifact worker.
   * The available arguments and options depend on the Update Module implementation and are, therefore, Type-specific.
   *
   */
  args?: string;
  /**
   * Raw file to be used to generate the artifact. It has to be the last part of request.
   */
  file: Blob | File;
};

export type DeploymentPhase = {
  /**
   * Phase identifier.
   */
  id?: string;
  /**
   * Percentage of devices to update in the phase.
   *
   */
  batch_size?: number;
  /**
   * Start date of a phase.
   * May be undefined for the first phase of a deployment.
   *
   */
  start_ts?: string;
  /**
   * Number of devices which already requested an update within this phase.
   *
   */
  device_count?: number;
};

export type Statistics = {
  /**
   * Number of successful deployments.
   */
  success: number;
  /**
   * Number of pending deployments.
   */
  pending: number;
  /**
   * Number of deployments being downloaded.
   */
  downloading: number;
  /**
   * Number of deployments devices are rebooting into.
   */
  rebooting: number;
  /**
   * Number of deployments devices being installed.
   */
  installing: number;
  /**
   * Number of failed deployments.
   */
  failure: number;
  /**
   * Do not have appropriate artifact for device type.
   */
  noartifact: number;
  /**
   * Number of devices unaffected by upgrade, since they are already running the specified software version.
   */
  'already-installed': number;
  /**
   * Number of deployments aborted by user.
   */
  aborted: number;
  /**
   * Number of deployments paused before install state.
   */
  pause_before_installing: number;
  /**
   * Number of deployments paused before reboot phase.
   */
  pause_before_rebooting: number;
  /**
   * Number of deployments paused before commit phase.
   */
  pause_before_committing: number;
};

export type DeploymentStatistics = {
  status?: Statistics;
  /**
   * Sum of sizes (in bytes) of all artifacts assigned to all device deployments,
   * which are part of this deployment.
   * If the same artifact is assigned to multiple device deployments,
   * its size will be counted multiple times.
   *
   */
  total_size?: number;
};

/**
 * Attribute filter predicate
 */
export type AttributeFilterPredicate = {
  scope: Scope;
  /**
   * Name of the attribute to be queried for filtering.
   *
   */
  attribute: string;
  /**
   * Type or operator of the filter predicate.
   */
  type: '$eq' | '$gt' | '$gte' | '$in' | '$lt' | '$lte' | '$ne' | '$nin' | '$exists';
  /**
   * The value of the attribute to be used in filtering.
   * Attribute type is implicit, inferred from the JSON type.
   * Supported types: number, string, array of numbers, array of strings.
   * Mixed arrays are not allowed.
   *
   */
  value: string;
};

/**
 * Detailed artifact.
 */
export type ArtifactV2 = {
  id: string;
  name: string;
  description: string;
  /**
   * An array of compatible device types.
   */
  device_types_compatible: Array<string>;
  info?: ArtifactInfo;
  /**
   * Idicates if artifact is signed or not.
   */
  signed?: boolean;
  updates?: Array<Update>;
  /**
   * List of Artifact provides.
   *
   * Map of key/value pairs, where both keys and values are strings.
   *
   */
  artifact_provides?: {
    [key: string]: string;
  };
  /**
   * List of Artifact depends.
   *
   * Map of key/value pairs, where keys are strings and values are lists of strings.
   *
   */
  artifact_depends?: {
    [key: string]: Array<string>;
  };
  /**
   * List of Clear Artifact provides.
   */
  clears_artifact_provides?: Array<string>;
  /**
   * Artifact total size in bytes - the size of the actual file that will be transferred to the device (compressed).
   *
   */
  size?: number;
  /**
   * Represents creation / last edition of any of the artifact properties.
   *
   */
  modified: string;
};

/**
 * List of releases
 */
export type ReleasesV2 = Array<ReleaseV2>;

/**
 * Groups artifacts with the same release name into a single resource.
 */
export type ReleaseV2 = {
  /**
   * release name.
   *
   */
  name?: string;
  /**
   * Last modification time for the release.
   *
   */
  modified?: string;
  /**
   * List of artifacts for this release.
   */
  artifacts?: Array<ArtifactV2>;
  /**
   * Tags assigned to the release used for filtering releases. Each tag
   * must be valid a ASCII string and contain only lowercase and uppercase
   * letters, digits, underscores, periods and hyphens.
   */
  tags?: Array<string>;
  /**
   * Additional information describing a Release limited to 1024 characters. Please use the v2 API to set this field.
   *
   */
  notes?: string;
};

/**
 * Fields to be updated in the given Release.
 */
export type ReleaseUpdate = {
  /**
   * Release notes, limited to maximum length.
   */
  notes?: string;
};

/**
 * Tags assigned to the release used for filtering releases. Each tag
 * must be valid a ASCII string and contain only lowercase and uppercase
 * letters, digits, underscores, periods and hyphens.
 */
export type Tags = Array<string>;

/**
 * Update types as present in the images.
 */
export type UpdateTypes = Array<string>;

/**
 * Inventory filter assigned to the deployment
 */
export type FilterV2 = {
  /**
   * Unique identifier of the saved filter.
   *
   */
  id: string;
  /**
   * Name of the saved filter.
   *
   */
  name: string;
  terms?: Array<AttributeFilterPredicate>;
};

export type DeploymentV2 = {
  /**
   * Deployment identifier
   */
  id: string;
  /**
   * Name of the deployment
   */
  name: string;
  /**
   * Name of the artifact to deploy
   */
  artifact_name: string;
  /**
   * Deployment's creation date and time
   */
  created: string;
  /**
   * Deployment's completion date and time
   */
  finished?: string;
  /**
   * Status of the deployment
   */
  status: 'scheduled' | 'pending' | 'inprogress' | 'finished';
  /**
   * Number of devices the deployment acted upon
   */
  device_count: number;
  /**
   * An array of artifact's identifiers.
   */
  artifacts?: Array<string>;
  /**
   * An array of groups the devices targeted by the deployment belong to.
   * Available only if the user created the deployment for a group or a single device (if the device was in a static group).
   *
   */
  groups?: Array<string>;
  /**
   * An array of deployments phases (if any were defined for the deployment).
   */
  phases?: Array<DeploymentPhase>;
  /**
   * The number of times a device can retry the deployment in case of failure, defaults to 0
   */
  retries?: number;
  /**
   * A valid JSON object defining the update control map.
   * *NOTE*: Available only in the Enterprise plan.
   *
   */
  update_control_map?: {
    [key: string]: unknown;
  };
  /**
   * max_devices denotes a limit on a number of completed deployments (failed or successful) above which the dynamic deployment will be finished.
   *
   */
  max_devices?: number;
  /**
   * In case of dynamic deployments this is a number of devices targeted initially (maching the filter at the moment of deployment creation).
   *
   */
  initial_device_count?: number;
  /**
   * Flag indicating if the deployment is dynamic or not.
   *
   */
  dynamic?: boolean;
  filter?: FilterV2;
  type?: 'configuration' | 'software';
  /**
   * A string containing a configuration object provided
   * with the deployment constructor.
   *
   */
  configuration?: string;
  /**
   * The flag idicating if the autogeneration of delta artifacts is enabled for a given deployment.
   *
   */
  autogenerate_delta?: boolean;
  statistics?: DeploymentStatistics;
};

export type NewDeploymentV2 = {
  name: string;
  artifact_name: string;
  /**
   * ID of a filter from inventory service.
   */
  filter_id: string;
  /**
   * Phased rollout feature is available only to Enterprise users.
   *
   */
  phases?: Array<NewDeploymentPhase>;
  /**
   * The number of times a device can retry the deployment in case of failure, defaults to 0
   */
  retries?: number;
  /**
   * max_devices denotes a limit on a number of completed deployments (failed or successful) above which the dynamic deployment will be finished
   *
   */
  max_devices?: number;
  /**
   * A valid JSON object defining the update control map.
   * *NOTE*: Available only in the Enterprise plan.
   *
   */
  update_control_map?: {
    [key: string]: unknown;
  };
  /**
   * The flag idicating if the autogeneration of delta artifacts is enabled for a given deployment.
   *
   */
  autogenerate_delta?: boolean;
};

/**
 * Releases used by active deployment.
 */
export type ReleasesDeleteError = {
  /**
   * Description of the error.
   */
  error?: string;
  /**
   * List of IDs of active deployments which are using releases from the request.
   */
  active_deployments?: Array<string>;
  /**
   * Request ID (same as in X-MEN-RequestID header).
   */
  request_id?: string;
};

export type DeltaJobsListItem = {
  /**
   * Identifier of the job
   *
   */
  id?: string;
  /**
   * Workflows id that corresponds to the job executed by the generator, it is an internal id important
   * to include in case of support requests
   *
   */
  delta_job_id?: string;
  /**
   * Release or artifact name of the second argument that we used to generate the delta
   *
   */
  to_version?: string;
  /**
   * Release or artifact name of the first argument that we used to generate the delta
   *
   */
  from_version?: string;
  /**
   * Array of the devices types names compatible with this artifact
   *
   */
  devices_types_compatible?: Array<string>;
  /**
   * Date we started the generation
   *
   */
  started?: string;
  /**
   * Gneration status
   *
   */
  status?: 'pending' | 'queued' | 'success' | 'failed' | 'artifact_uploaded';
};

export type DeltaJobDetailsItem = {
  /**
   * Identifier of a deployment
   *
   */
  deployment_id?: string;
  /**
   * Array of the devices types names compatible with this artifact
   *
   */
  devices_types_compatible?: Array<string>;
  /**
   * Target release name
   *
   */
  to_release?: string;
  /**
   * Source release name
   *
   */
  from_release?: string;
  /**
   * Gneration status
   *
   */
  status?: 'pending' | 'queued' | 'success' | 'failed' | 'artifact_uploaded';
  /**
   * Details of the delta generation job
   *
   */
  details?: string;
  /**
   * Exit code of the delta generation job
   *
   */
  exit_code?: number;
  /**
   * Size of the target artifact
   *
   */
  target_size?: number;
  /**
   * Size of the resulting delta artifact
   *
   */
  delta_artifact_size?: number;
};

export type AuthRequest = {
  /**
   * Vendor-specific JSON representation of the device identity data (MACs, serial numbers, etc.).
   */
  id_data: string;
  /**
   * The device's public key (PEM encoding), generated by the device or pre-provisioned by the vendor. Currently supported public algorithms are: RSA, Ed25519 and ECDSA P-256.
   *
   */
  pubkey: string;
  /**
   * Tenant token.
   */
  tenant_token?: string;
  /**
   * A device tier.
   */
  tier?: 'standard' | 'micro' | 'system';
  /**
   * External identity which can be used to verify devices managed by cloud providers.
   * Currently, only Azure IoT Edge devices are supported.
   *
   */
  external_id?: string;
};

/**
 * Tenant account limit.
 */
export type TenantLimit = {
  tenant_id: string;
  current_value: number;
  limit: number;
};

/**
 * External device descriptor
 */
export type ExternalDevice = {
  /**
   * ID assigned by external provider
   */
  id: string;
  /**
   * Name of the device
   */
  name: string;
  /**
   * Name of the external provider
   */
  provider: string;
  /**
   * Optional custom ID data
   */
  id_data?: string;
};

/**
 * Limit definition
 */
export type DeviceLimit = {
  limit: number;
};

/**
 * Admission status of the device.
 */
export type Status = {
  status: 'pending' | 'accepted' | 'rejected' | 'preauthorized';
};

/**
 * Device external identity.
 *
 */
export type ExternalIdentity = {
  /**
   * External identity.
   */
  data?: string;
  /**
   * Status flag.
   */
  active?: boolean;
};

export type Device = {
  /**
   * Mender assigned Device ID.
   */
  id?: string;
  identity_data?: IdentityData;
  status?: 'pending' | 'accepted' | 'rejected' | 'preauthorized' | 'noauth';
  /**
   * Created timestamp
   */
  created_ts?: string;
  /**
   * Updated timestamp
   */
  updated_ts?: string;
  /**
   * Time when accepted device contacted server for the last time.
   */
  check_in_time?: string;
  auth_sets?: Array<AuthSet>;
  /**
   * Devices that are part of ongoing decomissioning process will return True
   */
  decommissioning?: boolean;
  external_id?: ExternalIdentity;
};

/**
 * Counter type
 */
export type Count = {
  /**
   * The count of requested items.
   */
  count?: number;
};

/**
 * Device limit per tier
 */
export type DeviceTierLimits = {
  /**
   * The number of standard tier devices that can be accepted by the tenant.
   * A value of 0 or -1 means that an unlimited amount of standard tier devices can be accepted.
   *
   */
  standard: number;
  /**
   * The number of micro tier devices that can be accepted by the tenant.
   * A value of -1 means that an unlimited amount of micro tier devices can be accepted.
   *
   */
  micro: number;
  /**
   * The number of system tier devices that can be accepted by the tenant.
   * A value of -1 means that an unlimited amount of system tier devices can be accepted.
   *
   */
  system: number;
};

export type PreAuthSet = {
  /**
   * Indicates that despite the device having any authsets the preauthorization should proceed.
   */
  force?: boolean;
  identity_data: IdentityData;
  /**
   * The device's public key (PEM encoding), generated by the device or pre-provisioned by the vendor. Currently supported public algorithms are: RSA, Ed25519 and ECDSA P-256.
   */
  pubkey: string;
  /**
   * A device tier.
   */
  tier?: 'standard' | 'micro' | 'system';
};

/**
 * Authentication request.
 */
export type AutoAuthRequest = {
  /**
   * Vendor-specific JSON representation of the device identity data (MACs, serial numbers, etc.).
   */
  id_data: string;
  /**
   * The device's public key (PEM encoding), generated by the device or pre-provisioned by the vendor. Currently supported public algorithms are: RSA, ED25519 and ECDSA.
   *
   */
  pubkey: string;
  /**
   * Tenant token.
   */
  tenant_token?: string;
  /**
   * External identity which can be used to verify devices managed by cloud providers.
   * Currently, only Azure IoT Edge devices are supported.
   *
   */
  external_id?: string;
};

export type DeviceApiConfiguration = {
  [key: string]: string;
};

export type NewConfigurationDeployment = {
  /**
   * The number of times a device can retry the deployment in case of failure, defaults to 0
   */
  retries?: number;
  /**
   * A valid JSON object defining the update control map.
   * *NOTE*: Available only in the Enterprise plan.
   *
   */
  update_control_map?: {
    [key: string]: unknown;
  };
};

export type NewConfigurationDeploymentResponse = {
  /**
   * Deployment ID
   */
  deployment_id?: string;
};

export type ManagementApiConfiguration = {
  [key: string]: string;
};

export type DeviceConfiguration = {
  id?: string;
  configured?: ManagementApiConfiguration;
  reported?: ManagementApiConfiguration;
  /**
   * ID of the latest configuration deployment
   */
  deployment_id?: string;
  reported_ts?: string;
  updated_ts?: string;
};

export type ConnectionState = {
  /**
   * Device ID.
   */
  device_id?: string;
  /**
   * Device status.
   */
  status?: 'connected' | 'disconnected' | 'unknown';
  /**
   * Server-side timestamp of the last device information update.
   */
  updated_ts?: string;
  /**
   * Server-side timestamp of the device creation.
   */
  created_ts?: string;
};

export type FileUpload = {
  /**
   * The destination path on the device
   */
  path: string;
  /**
   * The numerical UID of the file on the device
   */
  uid?: number;
  /**
   * The numerical GID of the file on the device
   */
  gid?: number;
  /**
   * The octal representation of the mode of the file on the device
   */
  mode?: string;
  file?: Blob | File;
};

/**
 * Alert request
 */
export type Alert = {
  /**
   * A descriptive name of the alert
   *
   */
  name: string;
  /**
   * Alert severity level
   *
   */
  level: 'OK' | 'CRITICAL';
  subject: AlertSubject;
  /**
   * Time and date when the alert occured
   *
   */
  timestamp: string;
};

/**
 * Alert subject: the description of the alert origin
 *
 */
export type AlertSubject = {
  /**
   * Name of an entity that caused the alert
   *
   */
  name: string;
  /**
   * The type of executable that triggered the alert.
   *
   */
  type: string;
  /**
   * Status of an entity that caused the alert
   *
   */
  status: string;
  details?: AlertDetails;
};

/**
 * Additional details on the alert.
 *
 */
export type AlertDetails = {
  /**
   * Alert description.
   *
   */
  description?: string;
  /**
   * Log lines before matched pattern.
   *
   */
  lines_before?: Array<LineDescriptor>;
  /**
   * Log lines after matched pattern.
   *
   */
  lines_after?: Array<LineDescriptor>;
  line_matching?: LineDescriptor;
};

/**
 * Describes the data and line of a pattern-matched log line.
 *
 */
export type LineDescriptor = {
  line_number: number;
  data: string;
};

/**
 * Monitor configuration data.
 *
 */
export type DeviceMonitorConfiguration = {
  name: string;
  status: string;
  type: string;
};

export type MonitorDevice = {
  id: string;
  alerts_open_count: number;
  alerts_total_count: number;
  alerts: Array<Alert>;
};

/**
 * Monitor configuration data.
 *
 */
export type MonitorConfiguration = {
  name: string;
  status: string;
  type: 'log' | 'service' | 'dbus';
} & (
  | ({
      type: 'LogSubsystem';
    } & LogSubsystem)
  | ({
      type: 'ServiceSubsystem';
    } & ServiceSubsystem)
  | ({
      type: 'DBusSubsystem';
    } & DBusSubsystem)
);

/**
 * log subsystem specific configuration
 *
 */
export type LogSubsystem = {
  log: {
    /**
     * Log pattern
     *
     */
    pattern: string;
    /**
     * Path to the log file or command to execute to get the logs (prefixed with '@').
     *
     */
    path: string;
    /**
     * Number of seconds after which the pattern is considered expired and an OK is sent
     *
     */
    expire_seconds?: number;
  };
};

/**
 * service subsystem specific configuration
 *
 */
export type ServiceSubsystem = {
  service: {
    /**
     * Service name
     *
     */
    name: string;
    /**
     * Service type
     *
     */
    type: string;
  };
};

/**
 * dbus subsystem specific configuration
 *
 */
export type DBusSubsystem = {
  dbus: {
    /**
     * Check name.
     *
     */
    name: string;
    /**
     * DBus pattern to look for
     *
     */
    pattern: string;
    /**
     * DBus watch expression
     *
     */
    watch: string;
    /**
     * Number of seconds after which the alert is considered expired and an OK is sent
     *
     */
    alert_expiration?: number;
  };
};

/**
 * Attribute descriptor.
 */
export type Attribute = {
  /**
   * A human readable, unique attribute ID, e.g. 'device_type', 'ip_addr', 'cpu_load', etc.
   *
   */
  name: string;
  /**
   * Attribute description.
   */
  description?: string;
  /**
   * The current value of the attribute.
   *
   * Attribute type is implicit, inferred from the JSON type.
   *
   * Supported types: number, string, array of numbers, array of strings.
   * Mixed type arrays are not allowed.
   *
   */
  value: string;
};

export type DeviceNew = {
  /**
   * Mender-assigned unique ID.
   */
  id: string;
  /**
   * Timestamp of the most recent attribute update.
   */
  updated_ts?: string;
  /**
   * A list of attribute descriptors.
   */
  attributes?: Array<Attribute>;
};

/**
 * Object containing device id and device revision of the device to update.
 */
export type DeviceUpdate = {
  /**
   * Device identifier.
   */
  id: string;
  /**
   * Device object revision.
   */
  revision: number;
};

export type Groups = {
  /**
   * List of device's groups.
   */
  groups: Array<string>;
};

/**
 * Object containing list of device IDs and list of groups.
 */
export type DevicesInGroupsReq = {
  /**
   * List of device IDs.
   */
  devices: Array<string>;
  /**
   * List of group names.
   */
  groups: Array<string>;
};

export type DeviceInventory = {
  /**
   * Mender-assigned unique ID.
   */
  id?: string;
  /**
   * Timestamp of the most recent attribute update.
   */
  updated_ts?: string;
  /**
   * A list of attribute descriptors.
   */
  attributes?: Array<AttributeV2>;
};

/**
 * Error descriptor.
 */
export type ErrorNotFound = {
  /**
   * Description of the error.
   */
  error?: string;
  /**
   * Request ID (same as in X-MEN-RequestID header).
   */
  request_id?: string;
};

/**
 * Inventory attribute
 */
export type SelectAttribute = {
  /**
   * Attribute name.
   */
  attribute: string;
  scope: Scope;
};

/**
 * Attribute filter predicate
 */
export type FilterPredicate = {
  scope: Scope;
  /**
   * Attribute name.
   */
  attribute: string;
  /**
   * Type or operator of the filter predicate.
   *
   * | *Operator* | *Name*                       | *Argument type* |
   * |:----------:|:-----------------------------|:----------------|
   * | $eq        | Equal (`==`)                 | any             |
   * | $ne        | Not equal (`!=`)             | any             |
   * | $gt        | Greater than (`>`)           | any             |
   * | $gte       | Greater than or equal (`>=`) | any             |
   * | $lt        | Less than (`<`)              | any             |
   * | $lte       | Less than or equal (`<=`)    | any             |
   * | $ltne      | Less than or does not exist  | any             |
   * | $exists    | Attribute exists             | bool            |
   * | $in        | Is an element of             | array           |
   * | $nin       | Is not an element of         | array           |
   * | $regex     | Regex filter                 | string          |
   *
   */
  type: '$eq' | '$gt' | '$gte' | '$in' | '$lt' | '$lte' | '$ltne' | '$ne' | '$nin' | '$exists' | '$regex';
  /**
   * The value of the attribute to be used in filtering.
   * Attribute type is implicit, inferred from the JSON type.
   *
   * The $exists operator expects a boolean value: true means the specified
   * attribute exists, false means the specified attribute doesn't exist.
   *
   * The $regex operator expects a string as a Perl compatible regular expression
   * (PCRE), automatically anchored by ^. If the regular expression is not valid,
   * the filter will produce no results. If you need to specify options and flags,
   * you can provide the full regex in the format of /regex/flags, for example
   * `/[a-z]+/i`.
   *
   */
  value: string;
};

/**
 * Sort criteria definition
 */
export type SortCriteria = {
  /**
   * Attribute name.
   */
  attribute: string;
  scope: Scope;
  /**
   * Sort order.
   */
  order: 'asc' | 'desc';
};

/**
 * Attribute descriptor with scope (v2 APIs).
 */
export type AttributeV2 = {
  /**
   * A human readable, unique attribute ID, e.g. 'device_type', 'ip_addr', 'cpu_load', etc.
   *
   */
  name: string;
  scope: Scope;
  /**
   * Attribute description.
   */
  description?: string;
  /**
   * The current value of the attribute.
   *
   * Attribute type is implicit, inferred from the JSON type.
   *
   * Supported types: number, string, array of numbers, array of strings.
   * Mixed arrays are not allowed.
   *
   */
  value: string;
};

/**
 * Filter definition
 */
export type Filter = {
  /**
   * Unique identifier of the saved filter.
   *
   */
  id: string;
  /**
   * Name of the saved filter.
   *
   */
  name: string;
  terms?: Array<FilterPredicate>;
};

/**
 * Attribute descriptor.
 */
export type AttributeV1 = {
  /**
   * A human readable, unique attribute ID, e.g. 'device_type', 'ip_addr', 'cpu_load', etc.
   *
   */
  name: string;
  /**
   * The scope of the attribute.
   *
   * Scope is a string and acts as namespace for the attribute name.
   *
   */
  scope: string;
  /**
   * Attribute description.
   */
  description?: string;
  /**
   * The current value of the attribute.
   *
   * Attribute type is implicit, inferred from the JSON type.
   *
   * Supported types: number, string, array of numbers, array of strings.
   * Mixed type arrays are not allowed.
   *
   */
  value: string;
  /**
   * The date and time of last tag update in RFC3339 format.
   *
   */
  timestamp?: string;
};

/**
 * Tag descriptor.
 */
export type Tag = {
  /**
   * Tag is an attribute with 'tags' scope.
   *
   * A human readable, unique tag ID, e.g. 'location', 'environment', etc.
   *
   */
  name: string;
  /**
   * Tag description.
   */
  description?: string;
  /**
   * The current value of the tag.
   */
  value: string;
  /**
   * The date and time of last tag update in RFC3339 format.
   *
   */
  timestamp?: string;
};

export type DeviceInventoryV1 = {
  /**
   * Mender-assigned unique device ID.
   */
  id?: string;
  /**
   * Timestamp of the most recent attribute update.
   */
  updated_ts?: string;
  /**
   * A list of attribute descriptors.
   */
  attributes?: Array<AttributeV1>;
};

export type Group = {
  /**
   * Device group.
   */
  group: string;
};

/**
 * Filterable attribute
 */
export type FilterAttribute = {
  /**
   * Name of the attribute.
   */
  name: string;
  scope: Scope;
  /**
   * Number of occurrences of the attribute in the database.
   */
  count: number;
};

/**
 * Filter definition
 */
export type FilterDefinition = {
  /**
   * Name of the filter, must be unique.
   */
  name?: string;
  /**
   * List of filter predicates, chained with boolean AND operators to build the search condition definition.
   */
  terms?: Array<FilterPredicate>;
};

export type NewDevice = {
  /**
   * ID of the new device.
   */
  id: string;
  /**
   * Authorization status for the device.
   */
  status?: 'accepted' | 'noauth' | 'pending' | 'preauthorized' | 'rejected';
  auth_sets?: Array<AuthSet>;
  /**
   * The creation timestamp of the device.
   */
  created_ts?: string;
};

export type Integration = {
  /**
   * A unique integration identifier generated by the mender server
   */
  id?: string;
  provider: 'iot-hub' | 'iot-core' | 'webhook';
  credentials: Credentials;
  /**
   * A short human readable description (max 1024 characters).
   */
  description?: string;
  /**
   * An array of scopes for the integration. Currently we support deviceauth
   * and inventory scopes. The former will match the events related to a device
   * state (accepted, decomissioned), while the latter the inventory changed event.
   *
   */
  scopes?: Array<'deviceauth' | 'inventory'>;
};

export type Credentials = {
  /**
   * The credential type
   */
  type: 'aws' | 'sas' | 'http';
} & (AwsCredentials | AzureSharedAccessSecret | Http);

/**
 * AWS credentials in the form of access key id and secret access key, a region and a device policy name.
 */
export type AwsCredentials = {
  aws: {
    access_key_id: string;
    secret_access_key: string;
    region: string;
    device_policy_name: string;
  };
};

/**
 * Shared Access Secret is an authentication mechanism in the form of a connection string for Azure IoT Hub.
 */
export type AzureSharedAccessSecret = {
  connection_string: string;
};

export type DeviceState = {
  /**
   * The desired state for the device, as reported by the cloud/user.
   */
  desired?: unknown;
  /**
   * State reported by the device, this cannot be changed from the cloud.
   */
  reported?: unknown;
};

/**
 * HTTP Webhook configuration.
 */
export type Http = {
  http: {
    /**
     * The destination URL for the webhook. The webhook will send POST requests with event details to this target URL.
     */
    url: string;
    /**
     * An optional secret used to verify the integrity of the payload. The string must be in hexadecimal format.
     */
    secret?: string;
  };
};

export type Event = {
  /**
   * A unique event identifier generated by the Mender server
   */
  id?: string;
  /**
   * Type of the event
   */
  type?: 'device-provisioned' | 'device-decommissioned' | 'device-status-changed' | 'device-inventory-changed';
  delivery_statuses?: Array<{
    /**
     * The ID of the integration the status belongs.
     */
    integration_id: string;
    /**
     * Whether the event hook was executed successfully.
     */
    success: boolean;
    /**
     * The (HTTP) status code of the hook.
     */
    status_code?: number;
    /**
     * An error message if the hook failed.
     */
    error?: string;
  }>;
  /**
   * Creation timestamp
   */
  time?: string;
  data?:
    | ({
        type: 'device-provisioned' | 'device-decommissioned' | 'device-status-changed';
      } & DeviceAuthEvent)
    | ({
        type: 'device-inventory-changed';
      } & DeviceInventoryEvent);
};

/**
 * DeviceAuthEvent describes an event that relates to changes to a device's authentication data. The properties included depends on the event type: device provisioning includes the entire device with the accepted authentication set, status change events only includes the device id and the new status, and device decommissioning will only include the device id.
 */
export type DeviceAuthEvent = {
  /**
   * Device unique ID.
   */
  id: string;
  /**
   * The authentication status of the device.
   */
  status?: string;
  auth_sets?: Array<AuthSet>;
  /**
   * The time the device was initialized in Mender.
   */
  created_ts?: string;
};

/**
 * DeviceInventoryEvent describes an event that relates to changes to a device's inventory data.
 */
export type DeviceInventoryEvent = {
  /**
   * Device unique ID.
   */
  device_id: string;
  /**
   * Tenant ID.
   */
  tenant_id: string;
  /**
   * Arbitrary key-value pairs of inventory attributes as device has sent them
   */
  inventory: {
    [key: string]: unknown;
  };
};

/**
 * Update tenant information.
 */
export type TenantUpdateInternal = {
  /**
   * Name of the tenant's organization.
   */
  name?: string;
  /**
   * Plan assigned to the tenant account.
   */
  plan?: 'os' | 'enterprise' | 'professional';
  /**
   * Whether this account is free trial.
   */
  trial?: boolean;
  /**
   * When trial evaluation expires.
   */
  trial_expiration?: string;
  /**
   * Addons configuration.
   */
  addons?: Array<Addon>;
  api_limits?: TenantApiLimits;
  /**
   * True if the tenant is a service provider tenant.
   */
  service_provider?: boolean;
  /**
   * Maximum number of allowed child tenants
   */
  max_child_tenants?: string;
  /**
   * Planned suspention date and time, in ISO8601 format.
   */
  suspend_at?: string;
};

/**
 * Mender addon definition.
 */
export type Addon = {
  /**
   * Name of the addon (one of ['configure', 'troubleshoot']).
   */
  name?: string;
  /**
   * Enabled/disabled flag.
   */
  enabled?: boolean;
};

/**
 * Additional information about a tenant.
 */
export type TenantAdditionalInfo = {
  /**
   * Marketing
   */
  marketing?: boolean;
  /**
   * Campaign
   */
  campaign?: string;
};

/**
 * API burst limit definition.
 */
export type ApiBurst = {
  /**
   * HTTP verb.
   */
  action?: string;
  /**
   * URI of the resource subject to the limit.
   */
  uri?: string;
  /**
   * Minimum allowed interval, in seconds, between subsequent calls to 'action' on 'uri' (10 = one call every 10 seconds, etc.)
   */
  min_interval_sec?: number;
};

/**
 * API usage quota definition.
 */
export type ApiQuota = {
  /**
   * Maximum allowed number of calls within 'interval'.
   * A value of 0 means 'no limit'.
   *
   */
  max_calls?: number;
  /**
   * Interval definition, in seconds (60 = 1 minute, 3600 = 1 hour, etc.).
   */
  interval_sec?: number;
};

/**
 * Usage quota and burst limit definitions for an API type.
 */
export type ApiLimits = {
  /**
   * Collection of api burst limit definitions over specified API resources.
   */
  bursts?: Array<ApiBurst>;
  quota?: ApiQuota;
};

/**
 * API usage quota and burst limit definitions for a tenant - per API type.
 */
export type TenantApiLimits = {
  management?: ApiLimits;
  devices?: ApiLimits;
};

/**
 * Tenant descriptor.
 */
export type Tenant = {
  /**
   * Tenant ID.
   */
  id: string;
  /**
   * Name of the tenant's organization.
   */
  name: string;
  /**
   * Currently used tenant token.
   */
  tenant_token: string;
  /**
   * Status of the tenant account.
   */
  status?: 'active' | 'suspended';
  /**
   * Plan assigned to the tenant account.
   */
  plan?: 'os' | 'enterprise' | 'professional';
  /**
   * Whether this account is free trial.
   */
  trial?: boolean;
  /**
   * When trial evaluation expires.
   */
  trial_expiration?: string;
  /**
   * Addons configuration.
   */
  addons?: Array<Addon>;
  /**
   * Whether this account is a service provider.
   */
  service_provider?: boolean;
  /**
   * The ID of the service provider tenant managing this tenant.
   */
  parent_tenant_id?: string;
  additional_info?: TenantAdditionalInfo;
  api_limits?: TenantApiLimits;
  /**
   * Creation date and time, in ISO8601 format.
   */
  created_at?: string;
  /**
   * Last update date and time, in ISO8601 format.
   */
  updated_at?: string;
  /**
   * Count of accepted devices for the tenant.
   */
  device_count?: number;
  /**
   * Device limit for the tenant.
   */
  device_limit?: number;
};

/**
 * Status of a tenant account.
 */
export type TenantStatus = {
  status: 'active' | 'suspended';
};

/**
 * Card information stored in Stripe. The full type description is available at "https://raw.githubusercontent.com/stripe/openapi/master/openapi/spec3.yaml#/components/schemas/payment_method_card"
 */
export type CardData = {
  /**
   * Card brand. Can be `amex`, `diners`, `discover`, `jcb`, `mastercard`, `unionpay`, `visa`, or `unknown`.
   */
  brand?: string;
  /**
   * Checks on Card address and CVC if provided.
   */
  checks?: {
    address_line1_check?: string;
    address_postal_code_check?: string;
    cvc_check?: string;
  };
  /**
   * Two-letter ISO code representing the country of the card. You could use this attribute to get a sense of the international breakdown of cards you've collected.
   */
  country?: string;
  /**
   * Two-digit number representing the card's expiration month.
   */
  exp_month?: number;
  /**
   * Four-digit number representing the card's expiration year.
   */
  exp_year?: number;
  /**
   * Uniquely identifies this particular card number. You can use this attribute to check whether two customers whove signed up with you are using the same card number,for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
   */
  fingerprint?: string;
  /**
   * Card funding type. Can be `credit`, `debit`, `prepaid`, or `unknown`.
   */
  funding?: string;
  /**
   * The last four digits of the card.
   */
  last4?: string;
  /**
   * Contains details on how this Card maybe be used for 3D Secure authentication.
   */
  three_d_secure_usage?: {
    supported?: boolean;
  };
  /**
   * If this Card is part of a card wallet, this contains the details of the card wallet.
   */
  wallet?: {
    dynamic_last4?: string;
    type?: string;
  };
};

/**
 * Subscription information stored in Stripe. The full type description is available at "https://raw.githubusercontent.com/stripe/openapi/master/openapi/spec3.yaml#/components/schemas/subscription"
 */
export type SubscriptionData = {
  [key: string]: unknown;
};

/**
 * Billing related data, such as credit card information and next billing date
 */
export type BillingInfo = {
  card?: CardData;
  subscription?: SubscriptionData;
};

/**
 * Stripe setup intent data.
 */
export type CardSetupData = {
  /**
   * Setup intent id.
   */
  intent_id: string;
  /**
   * Setup intent secret.
   */
  secret: string;
};

export type AddressUpdate = {
  country?: string;
  state?: string;
  city?: string;
  postal_code?: string;
  line1?: string;
  line2?: string;
};

export type Address = AddressUpdate & unknown;

/**
 * Billing profile contains information about the customer.
 *
 */
export type BillingProfile = {
  /**
   * The customer's email address.
   */
  email: string;
  /**
   * The customer's full name or business name.
   */
  name: string;
  /**
   * The customer's phone number.
   */
  phone?: string;
  address: Address & unknown;
  /**
   * Mailing and shipping address for the customer. Appears on invoices.
   *
   */
  shipping: {
    /**
     * Name of the recipient.
     */
    name?: string;
    /**
     * Phone number of the recipient (including extension).
     */
    phone?: string;
    address?: Address & unknown;
  };
};

/**
 * Billing profile contains partial billing information.
 */
export type BillingProfileUpdate = {
  /**
   * The customer's email address.
   */
  email?: string;
  /**
   * The customer's full name or business name.
   */
  name?: string;
  /**
   * The customer's phone number.
   */
  phone?: string;
  address?: AddressUpdate & unknown;
  /**
   * Mailing and shipping address for the customer. Appears on invoices.
   *
   */
  shipping?: {
    /**
     * Name of the recipient.
     */
    name?: string;
    /**
     * Phone number of the recipient (including extension).
     */
    phone?: string;
    address?: AddressUpdate & unknown;
  };
};

export type Invoice = {
  id?: string;
  period_start?: string;
  period_end?: string;
  /**
   * Total amount in the minimum transactable unit for the given currency (cents for USD).
   *
   */
  total?: number;
  /**
   * The currency of the amount
   */
  currency?: string;
  lines?: Array<InvoiceLineItem>;
};

export type InvoiceLineItem = {
  /**
   * A human readable description of the item.
   */
  description: string;
  /**
   * The number of units for the given line item.
   */
  quantity: number;
  /**
   * The amount in the minimum transactable unit for the given currency (cents for USD).
   */
  amount: number;
  /**
   * The currency of amount.
   */
  currency: string;
  /**
   * The name of the product for this item.
   */
  product?: string;
  /**
   * The name of the addon for this item if this is an addon.
   */
  addon?: string;
  /**
   * Whether this item was generated to prorate changes to the subscription within the subscription period.
   */
  proration?: boolean;
};

export type PreviewRequest = SubscriptionRequest & {
  preview_mode?: 'next' | 'recurring';
};

export type Subscription = SubscriptionRequest & {
  /**
   * The unique subscription ID.
   */
  id?: string;
  /**
   * The subscription status.
   */
  status?: 'active' | 'canceled' | 'incomplete' | 'past_due' | 'unpaid';
};

export type SubscriptionRequest = {
  plan?: TenantPlan;
  /**
   * The requested product and additional properties like quantity and addons
   */
  products?: Array<Product>;
};

export type Product = {
  name?: 'mender_standard';
  quantity: number;
  addons?: Array<Addon>;
};

/**
 * Plan assigned to the tenant account.
 */
export const TenantPlan = {
  OS: 'os',
  PROFESSIONAL: 'professional',
  ENTERPRISE: 'enterprise'
} as const;

/**
 * Plan assigned to the tenant account.
 */
export type TenantPlan = (typeof TenantPlan)[keyof typeof TenantPlan];

/**
 * Checkout data.
 */
export type CheckoutData = {
  /**
   * Stripe client secret.
   */
  secret: string;
};

/**
 * Contact support request.
 */
export type SupportRequest = {
  /**
   * Message subject.
   */
  subject: string;
  /**
   * Message body.
   */
  body: string;
};

/**
 * New Tenant
 */
export type NewTenant = {
  /**
   * Name of the tenant.
   */
  name?: string;
  admin?: {
    /**
     * Email address of the admin user
     */
    email?: string;
    /**
     * Password of the admin user, must be provided if not using SSO
     */
    password?: string;
    /**
     * Alternative SSO login schemes, must be provided if password is empty
     */
    login?: {
      [key: string]: unknown;
    };
    /**
     * Send reset password email to the admin user
     */
    send_reset_password?: boolean;
  };
  users?: Array<{
    /**
     * Email address of an existing user to be added to the newly created tenant
     */
    email?: string;
    /**
     * Role of the user to be added
     */
    role?: string;
  }>;
  /**
   * Device limit for the tenant.
   */
  device_limit?: number;
  /**
   * Enable server side binary delta generation for the tenant.
   */
  binary_delta?: boolean;
  /**
   * Enable SSO for the tenant.
   */
  sso?: boolean;
  /**
   * Restrict SSO for the children tenants to only that of the parent. No SSO changes allowed in children if set to true.
   */
  restrict_sso_to_parent?: boolean;
};

/**
 * Cancellation request of a tenant account.
 */
export type CancelRequest = {
  reason: string;
};

/**
 * Update Tenant
 */
export type UpdateChildTenant = {
  /**
   * Name of the tenant.
   */
  name?: string;
  /**
   * Device limit for the tenant.
   */
  device_limit?: number;
};

/**
 * Plan/add-on change request of a tenant account.
 */
export type PlanChangeRequest = {
  current_plan?: string;
  requested_plan?: string;
  current_addons?: string;
  requested_addons?: string;
  user_message?: string;
};

/**
 * User descriptor.
 */
export type User = {
  /**
   * A unique email address.
   */
  email: string;
  /**
   * User Id.
   */
  id: string;
  /**
   * Server-side timestamp of the user creation.
   *
   */
  created_ts?: string;
  /**
   * Server-side timestamp of the last user information update.
   *
   */
  updated_ts?: string;
  /**
   * Timestamp the of last successful login.
   */
  login_ts?: string;
  /**
   * Indicates if the user's email address has been verified.
   *
   */
  verified?: boolean;
  /**
   * User Two Factor Authentication status.
   */
  tfa_status?: string;
  /**
   * List of user roles.
   */
  roles?: Array<string>;
  /**
   * Flag indicating wether to trigger password reset on user creation.
   */
  send_reset_password?: boolean;
};

export type TenantInfo = {
  /**
   * Tenant identifier of a tenant, user will log in to by default.
   */
  tenant_id?: string;
  /**
   * List of tenant Ids user can login to.
   */
  tenant_ids?: Array<string>;
};

export type TenantIdName = {
  /**
   * Tenant identifier.
   */
  id: string;
  /**
   * Tenant name.
   */
  name: string;
};

export type TenantsIdName = Array<TenantIdName>;

export type UserWithTenantInfo = User & TenantInfo & TenantsIdName;

/**
 * New user descriptor.
 */
export type UserNewInternal = {
  /**
   * User's email.
   */
  email: string;
  /**
   * User's password.
   */
  password: string;
  /**
   * This paramter is deprecated _since Thu Jul 6 2023_, the propagation
   * of user information to tenantadm is disabled permanently.
   *
   */
  propagate?: boolean;
  /**
   * Unique id to allow a user to log in using a magic link
   */
  magic_id?: string;
  /**
   * Send reset password email to the user
   */
  send_reset_password?: boolean;
};

export type Emails = {
  /**
   * List of users emails.
   */
  emails: Array<string>;
};

/**
 * Tenant account limits.
 */
export type UseradmLimit = {
  count?: number;
  max: number;
};

/**
 * Tenant account limits.
 */
export type Limits = {
  users: UseradmLimit;
};

/**
 * Features descriptor.
 */
export type Features = {
  rbac?: boolean;
  audit_logs?: boolean;
  dynamic_groups?: boolean;
  terminal?: boolean;
  file_transfer?: boolean;
  configuration?: boolean;
  monitoring?: boolean;
  reporting?: boolean;
};

/**
 * Plan descriptor.
 */
export type Plan = {
  /**
   * Unique name of the plan.
   *
   */
  name: string;
  /**
   * Short information about the plan.
   *
   */
  display_name: string;
  features: Features;
};

/**
 * Plan limits descriptor.
 */
export type PlanLimits = {
  devices?: number;
  users?: number;
  audit_logs_days?: number;
};

/**
 * Combination of plan and limits objects.
 */
export type PlanBindingDetails = {
  plan?: Plan;
  limits?: PlanLimits;
};

/**
 * Combination of plan and limits objects.
 */
export type PlanBinding = {
  plan_name?: string;
  limits?: PlanLimits;
};

/**
 * Tenant ids data.
 */
export type TenantIdsData = {
  tenant_ids: Array<string>;
  /**
   * Optional RBAC role name to assign to the user. Defaults to: RBAC_ROLE_OBSERVER.
   */
  role?: string;
};

/**
 * Log in options
 */
export type LoginOptions = {
  /**
   * Generate a JWT token with no expiration date.
   */
  no_expiry?: boolean;
  /**
   * Two factor authentication token, required if two factor authentication is
   * enabled and tenant's plan is Professional or Enterprise.
   *
   */
  token2fa?: string;
};

/**
 * New user descriptor.
 */
export type UserNew = {
  /**
   * A unique email address. Non-ascii characters are invalid.
   */
  email: string;
  /**
   * Password.
   */
  password?: string;
  /**
   * Alternative login schemes
   */
  login?: {
    [key: string]: unknown;
  };
  /**
   * SSO login schemes
   */
  sso?: Array<SsoObject>;
};

/**
 * Single Sign On descriptor.
 */
export type SsoObject = {
  /**
   * An id of the identity provider.
   */
  id: string;
  /**
   * Single Sign On provider kind.
   */
  kind: string;
  /**
   * Single Sign On subject.
   */
  subject?: string;
};

/**
 * Update user information.
 */
export type UserUpdate = {
  /**
   * A unique email address.
   */
  email?: string;
  /**
   * New password.
   */
  password?: string;
  /**
   * Current password.
   */
  current_password?: string;
  /**
   * List of roles for the user. If not provided existing roles are kept.
   */
  roles?: Array<string>;
};

/**
 * Update user information.
 */
export type OwnUserUpdate = {
  /**
   * A unique email address.
   */
  email?: string;
  /**
   * New password.
   */
  password?: string;
  /**
   * Current password.
   */
  current_password?: string;
};

/**
 * Personal Access Token Request.
 */
export type PersonalAccessTokenRequest = {
  /**
   * Name of a token.
   */
  name: string;
  /**
   * Expiration time in seconds (maximum one year - 31536000s).
   * If you omit it or set it to zero, the Personal Access Token will never expire.
   *
   */
  expires_in?: number;
};

/**
 * Personal Access Token Object.
 */
export type PersonalAccessToken = {
  /**
   * Token identifier.
   */
  id: string;
  /**
   * Name of a token.
   */
  name: string;
  /**
   * Date of last usage of a token. The accuracy is 5 minutes.
   *
   */
  last_used?: string;
  /**
   * Expiration date.
   */
  expiration_date: string;
  /**
   * Server-side timestamp of the token creation.
   *
   */
  created_ts: string;
};

/**
 * User settings.
 */
export type Settings = {
  /**
   * Enable/disable two-factor authentication for this user.
   */
  '2fa'?: 'enabled' | 'disabled';
};

/**
 * Password reset request
 */
export type PasswordResetRequest = {
  /**
   * User's email address
   */
  email: string;
};

/**
 * Password reset completion
 */
export type PasswordResetCompletion = {
  /**
   * Secret hash received by email by the user
   */
  secret: string;
  /**
   * New password of the user
   */
  password: string;
};

/**
 * Email Verification request
 */
export type EmailVerificationRequest = {
  /**
   * User's email address
   */
  email: string;
};

/**
 * Email Verification completion
 */
export type EmailVerificationCompletion = {
  /**
   * Secret hash received by email by the user
   */
  secret: string;
};

/**
 * Metadata structure.
 */
export type SamlMetadata = {
  /**
   * Metadata Id.
   */
  id: string;
  /**
   * Metadata Issuer.
   */
  issuer: string;
  /**
   * Date after which the data is not valid.
   */
  valid_until: string;
};

/**
 * Role descriptor.
 */
export type RoleV1 = {
  /**
   * A unique name.
   */
  name: string;
  /**
   * Description of the role, as shown in the UI.
   */
  description?: string;
  permission_sets_with_scope?: Array<PermissionSetWithScope>;
};

/**
 * Permission set with optional scope.
 */
export type PermissionSetWithScope = {
  /**
   * Unique permission set name.
   */
  name: string;
  scope?: PermissionSetScope;
};

export type PermissionSetScope = {
  /**
   * Type of the scope.
   */
  type: 'DeviceGroups' | 'ReleaseTags';
  value: Array<string>;
};

/**
 * Role descriptor.
 */
export type Role = {
  /**
   * A unique name.
   */
  name: string;
  /**
   * Description of the role, as shown in the UI.
   */
  description?: string;
  permissions?: Array<RolePermission>;
};

/**
 * Role permission
 */
export type RolePermission = {
  /**
   * Action
   */
  action: 'any' | 'http' | 'CREATE_DEPLOYMENT' | 'MANAGE_DEVICE' | 'REMOTE_TERMINAL' | 'VIEW_DEVICE';
  object: RolePermissionObject;
};

/**
 * Role permission object
 */
export type RolePermissionObject = {
  /**
   * Type
   */
  type: string;
  /**
   * Value
   */
  value: string;
};

/**
 * Permission set descriptor.
 */
export type PermissionSet = {
  /**
   * A unique name.
   */
  name: string;
  action?: string;
  object?: string;
  /**
   * Description of the permission set.
   */
  description?: string;
  permissions: Array<Permission>;
  supported_scope_types?: Array<string>;
};

export type Permission = {
  /**
   * Action
   */
  action: 'any' | 'http';
  object: PermissionObject;
};

export type PermissionObject = {
  /**
   * Type
   */
  type: string;
  /**
   * Value
   */
  value: string;
};

/**
 * General product feedback
 */
export type FeedbackProduct = {
  /**
   * User satisfaction
   */
  score?: number;
  /**
   * Optional feedback from the user.
   */
  message?: string;
};

/**
 * AI feedback form.
 */
export type FeedbackAi = {
  /**
   * Was this feature useful?
   */
  useful: boolean;
  /**
   * The deployment ID where this feedback was triggered for context.
   */
  deployment_id: string;
  /**
   * The device ID where this feedback was triggered for context.
   */
  device_id: string;
};

/**
 * CLI parameters
 */
export type CliParams = {
  command?: Array<string>;
  executionTimeOut?: number;
};

/**
 * HTTP parameters
 */
export type HttpParams = {
  uri?: string;
  method?: string;
  contentType?: string;
  body?: string;
  json?: {
    [key: string]: unknown;
  };
  headers?: {
    [key: string]: unknown;
  };
  statusCodes?: Array<number>;
  connectionTimeOut?: number;
  readTimeOut?: number;
};

/**
 * Task definition
 */
export type Task = {
  name: string;
  type: string;
  retries?: number;
  retryDelaySeconds?: number;
  requires?: Array<string>;
  cli?: CliParams;
  http?: HttpParams;
};

export type Workflow = {
  name: string;
  description?: string;
  version: number;
  schemaversion?: number;
  tasks: Array<Task>;
  inputParameters?: Array<string>;
};

export type JobObject = {
  id?: string;
  workflowName?: string;
  inputParameters?: Array<InputParameter>;
  status?: string;
  results?: Array<TaskResult>;
  insert_time?: string;
  version?: string;
};

/**
 * The token in base64-encoded form.
 */
export type Authentication = string;

/**
 * A request identification
 */
export type RequestId = string;

export type PingData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/auditlogs/alive';
};

export type PingErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type PingError = PingErrors[keyof PingErrors];

export type PingResponses = {
  /**
   * Successful response.
   */
  204: void;
};

export type PingResponse = PingResponses[keyof PingResponses];

export type AuditlogsInternalCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/auditlogs/health';
};

export type AuditlogsInternalCheckHealthErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
  /**
   * Service unavailable
   */
  503: _Error;
};

export type AuditlogsInternalCheckHealthError = AuditlogsInternalCheckHealthErrors[keyof AuditlogsInternalCheckHealthErrors];

export type AuditlogsInternalCheckHealthResponses = {
  /**
   * Successful response.
   */
  204: void;
};

export type AuditlogsInternalCheckHealthResponse = AuditlogsInternalCheckHealthResponses[keyof AuditlogsInternalCheckHealthResponses];

export type DeleteAuditLogsData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/auditlogs/tenants/{tenant_id}';
};

export type DeleteAuditLogsErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteAuditLogsError = DeleteAuditLogsErrors[keyof DeleteAuditLogsErrors];

export type DeleteAuditLogsResponses = {
  /**
   * All the tenant logs have been successfully deleted.
   */
  204: void;
};

export type DeleteAuditLogsResponse = DeleteAuditLogsResponses[keyof DeleteAuditLogsResponses];

export type GetAuditLogsInternalData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Number of results per page.
     */
    per_page?: number;
    /**
     * List only log entries created before and equal to Unix timestamp (UTC)
     */
    created_before?: number;
    /**
     * List only log entries created after and equal to Unix timestamp (UTC)
     */
    created_after?: number;
    /**
     * If present, limits the results only to logs where actor has given id.
     */
    actor_id?: string;
    /**
     * If present, limits the results only to logs where actor is of a given type.
     */
    actor_type?: 'user' | 'device';
    /**
     * If present, limits the results only to logs where actors has given email address.
     */
    actor_email?: string;
    /**
     * If present, limits the results only to logs where object has given id.
     */
    object_id?: string;
    /**
     * If present, limits the results only to logs where object is of a given type.
     */
    object_type?: 'user' | 'deployment' | 'artifact' | 'device';
    /**
     * If present, limits the results only to logs where object is a deployment with a given name.
     */
    object_deployment_name?: string;
    /**
     * Supports sorting the log list by creation date.
     * By default logs are sorted by creation date in descending order (newest first).
     *
     */
    sort?: 'asc' | 'desc';
  };
  url: '/api/internal/v1/auditlogs/tenants/{tenant_id}/logs';
};

export type GetAuditLogsInternalErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetAuditLogsInternalError = GetAuditLogsInternalErrors[keyof GetAuditLogsInternalErrors];

export type GetAuditLogsInternalResponses = {
  /**
   * ListOfLogs
   *
   * A list of audit logs is returned.
   */
  200: Array<AuditLog>;
};

export type GetAuditLogsInternalResponse = GetAuditLogsInternalResponses[keyof GetAuditLogsInternalResponses];

export type SaveAuditLogData = {
  body: AuditLog;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/auditlogs/tenants/{tenant_id}/logs';
};

export type SaveAuditLogErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type SaveAuditLogError = SaveAuditLogErrors[keyof SaveAuditLogErrors];

export type SaveAuditLogResponses = {
  /**
   * Event has been successfully logged.
   */
  201: unknown;
};

export type GetAuditLogsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Number of results per page.
     */
    per_page?: number;
    /**
     * List only log entries created before and equal to Unix timestamp (UTC)
     */
    created_before?: number;
    /**
     * List only log entries created after and equal to Unix timestamp (UTC)
     */
    created_after?: number;
    /**
     * If present, limits the results only to logs where the actor has a given id.
     */
    actor_id?: string;
    /**
     * If present, limits the results only to logs where the actor is of a given type.
     */
    actor_type?: 'user' | 'device';
    /**
     * If present, limits the results only to logs where the actor has a given email address.
     */
    actor_email?: string;
    /**
     * If present, limits the results only to logs where the object has a given id.
     */
    object_id?: string;
    /**
     * If present, limits the results only to logs where the object is of a given type.
     */
    object_type?: 'tenant' | 'user' | 'deployment' | 'artifact' | 'device';
    /**
     * If present, limits the results only to logs where the object is a deployment and has a given name.
     */
    object_deployment_name?: string;
    /**
     * Supports sorting the log list by creation date.
     * By default logs are sorted by creation date in descending order (newest first).
     *
     */
    sort?: 'asc' | 'desc';
  };
  url: '/api/management/v1/auditlogs/logs';
};

export type GetAuditLogsErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user has sent too many requests in a given amount of time.
   *
   */
  429: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetAuditLogsError = GetAuditLogsErrors[keyof GetAuditLogsErrors];

export type GetAuditLogsResponses = {
  /**
   * ListOfLogs
   *
   * A list of audit logs is returned.
   */
  200: Array<AuditLog>;
};

export type GetAuditLogsResponse = GetAuditLogsResponses[keyof GetAuditLogsResponses];

export type ExportAuditLogsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Limit number of logs returned
     */
    limit?: number;
    /**
     * List only log entries created before and equal to Unix timestamp (UTC)
     */
    created_before?: number;
    /**
     * List only log entries created after and equal to Unix timestamp (UTC)
     */
    created_after?: number;
    /**
     * If present, limits the results only to logs where the actor has a given id.
     */
    actor_id?: string;
    /**
     * If present, limits the results only to logs where the actor is of a given type.
     */
    actor_type?: 'user' | 'device';
    /**
     * If present, limits the results only to logs where the actors has a given email address.
     */
    actor_email?: string;
    /**
     * If present, limits the results only to logs where the object has a given id.
     */
    object_id?: string;
    /**
     * If present, limits the results only to logs where the object is of a given type.
     */
    object_type?: 'user' | 'deployment' | 'artifact' | 'device';
    /**
     * If present, limits the results only to logs where the object is a deployment and has a given name.
     */
    object_deployment_name?: string;
    /**
     * Supports sorting the log list by creation date.
     * By default logs are sorted by creation date in descending order (newest first).
     *
     */
    sort?: 'asc' | 'desc';
    /**
     * Format string used to separate nested fields in the exported csv header
     *
     */
    format_separator?: string;
    /**
     * Header fields to ignore in the exported document (e.g. ignore=actor.id)
     *
     */
    ignore?: string;
  };
  url: '/api/management/v1/auditlogs/logs/export';
};

export type ExportAuditLogsErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user has sent too many requests in a given amount of time.
   *
   */
  429: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ExportAuditLogsError = ExportAuditLogsErrors[keyof ExportAuditLogsErrors];

export type ExportAuditLogsResponses = {
  /**
   * Successful response.
   *
   * Document follows in response body (chunked encoding).
   *
   */
  200: string;
};

export type ExportAuditLogsResponse = ExportAuditLogsResponses[keyof ExportAuditLogsResponses];

export type DeviceListArtifactsData = {
  body?: never;
  path?: never;
  query: {
    /**
     * name of the release
     */
    release_name: string;
    /**
     * Device type of device
     */
    device_type: string;
  };
  url: '/api/devices/v1/deployments/artifacts';
};

export type DeviceListArtifactsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceListArtifactsError = DeviceListArtifactsErrors[keyof DeviceListArtifactsErrors];

export type DeviceListArtifactsResponses = {
  /**
   * Successful response.
   */
  200: Array<Artifact>;
};

export type DeviceListArtifactsResponse = DeviceListArtifactsResponses[keyof DeviceListArtifactsResponses];

export type DeviceShowArtifactData = {
  body?: never;
  path: {
    /**
     * Artifact identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/devices/v1/deployments/artifacts/{id}';
};

export type DeviceShowArtifactErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceShowArtifactError = DeviceShowArtifactErrors[keyof DeviceShowArtifactErrors];

export type DeviceShowArtifactResponses = {
  /**
   * Successful response.
   */
  200: Artifact;
};

export type DeviceShowArtifactResponse = DeviceShowArtifactResponses[keyof DeviceShowArtifactResponses];

export type DevicesDownloadArtifactData = {
  body?: never;
  path: {
    /**
     * Artifact identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/devices/v1/deployments/artifacts/{id}/download';
};

export type DevicesDownloadArtifactErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DevicesDownloadArtifactError = DevicesDownloadArtifactErrors[keyof DevicesDownloadArtifactErrors];

export type DevicesDownloadArtifactResponses = {
  /**
   * Successful response.
   */
  200: ArtifactLink;
};

export type DevicesDownloadArtifactResponse = DevicesDownloadArtifactResponses[keyof DevicesDownloadArtifactResponses];

export type DeviceCheckUpdateData = {
  body?: never;
  path?: never;
  query: {
    /**
     * currently installed artifact
     */
    artifact_name: string;
    /**
     * Device type of device
     */
    device_type: string;
  };
  url: '/api/devices/v1/deployments/device/deployments/next';
};

export type DeviceCheckUpdateErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceCheckUpdateError = DeviceCheckUpdateErrors[keyof DeviceCheckUpdateErrors];

export type DeviceCheckUpdateResponses = {
  /**
   * Successful response.
   */
  200: DeploymentInstructions;
  /**
   * No updates for device.
   */
  204: void;
};

export type DeviceCheckUpdateResponse = DeviceCheckUpdateResponses[keyof DeviceCheckUpdateResponses];

export type CheckUpdateDependsData = {
  /**
   * Key-value map of strings which describes the artifact(s) installed on the device and the
   * device itself. It is used to determine the next deployment. The keys device_type and
   * artifact_name are mandatory, additional free-form key-value pairs can be specified.
   *
   */
  body: CheckUpdateDependsRequest;
  path?: never;
  query?: never;
  url: '/api/devices/v1/deployments/device/deployments/next';
};

export type CheckUpdateDependsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CheckUpdateDependsError = CheckUpdateDependsErrors[keyof CheckUpdateDependsErrors];

export type CheckUpdateDependsResponses = {
  /**
   * Successful response.
   */
  200: DeploymentInstructions;
  /**
   * No updates for device.
   */
  204: void;
};

export type CheckUpdateDependsResponse = CheckUpdateDependsResponses[keyof CheckUpdateDependsResponses];

export type UpdateDeploymentStatusData = {
  /**
   * Deployment status.
   */
  body: DeploymentStatus;
  path: {
    /**
     * Deployment identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/devices/v1/deployments/device/deployments/{id}/status';
};

export type UpdateDeploymentStatusErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Status already set to aborted.
   */
  409: unknown;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateDeploymentStatusError = UpdateDeploymentStatusErrors[keyof UpdateDeploymentStatusErrors];

export type UpdateDeploymentStatusResponses = {
  /**
   * Status updated successfully.
   */
  204: void;
};

export type UpdateDeploymentStatusResponse = UpdateDeploymentStatusResponses[keyof UpdateDeploymentStatusResponses];

export type ReportDeploymentLogData = {
  /**
   * Deployment log
   */
  body: DeploymentLog;
  path: {
    /**
     * Deployment identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/devices/v1/deployments/device/deployments/{id}/log';
};

export type ReportDeploymentLogErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ReportDeploymentLogError = ReportDeploymentLogErrors[keyof ReportDeploymentLogErrors];

export type ReportDeploymentLogResponses = {
  /**
   * The deployment log uploaded successfully.
   */
  204: void;
};

export type ReportDeploymentLogResponse = ReportDeploymentLogResponses[keyof ReportDeploymentLogResponses];

export type FetchConfigurationData = {
  body?: never;
  path: {
    /**
     * Deployment UUID
     */
    deployment_id: string;
    /**
     * Device type of the calling device
     */
    device_type: string;
    /**
     * Device UUID
     */
    device_id: string;
  };
  query: {
    /**
     * Time of link expire
     */
    'x-men-expire': string;
    /**
     * Signature of the URL link
     */
    'x-men-signature': string;
    /**
     * Device tenant ID
     */
    tenant_id?: string;
  };
  url: '/api/devices/v1/deployments/download/configuration/{deployment_id}/{device_type}/{device_id}';
};

export type FetchConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The download link has expired or the signature is invalid.
   */
  403: unknown;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type FetchConfigurationError = FetchConfigurationErrors[keyof FetchConfigurationErrors];

export type FetchConfigurationResponses = {
  /**
   * Artifact file
   */
  200: Blob | File;
};

export type FetchConfigurationResponse = FetchConfigurationResponses[keyof FetchConfigurationResponses];

export type CheckUpdateData = {
  /**
   * Request which describes the artifact(s) installed on the devices and the suppported features. The device_provides attribute contains a key-value map of strings which describes the artifact(s) installed on the device and the device itself. It is used to determine the next deployment. The keys device_type and artifact_name are mandatory, additional free-form key-value pairs can be specified.
   *
   */
  body: CheckUpdateRequest;
  path?: never;
  query?: never;
  url: '/api/devices/v2/deployments/device/deployments/next';
};

export type CheckUpdateErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CheckUpdateError = CheckUpdateErrors[keyof CheckUpdateErrors];

export type CheckUpdateResponses = {
  /**
   * Successful response.
   */
  200: DeploymentInstructionsV2;
  /**
   * No updates for device.
   */
  204: void;
};

export type CheckUpdateResponse = CheckUpdateResponses[keyof CheckUpdateResponses];

export type GetUpdateControlMapData = {
  body?: never;
  path: {
    /**
     * Deployment identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/devices/v2/deployments/device/deployments/{id}/update_control_map';
};

export type GetUpdateControlMapErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Device deployment with given ID does not exist
   * or has been finished.
   *
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetUpdateControlMapError = GetUpdateControlMapErrors[keyof GetUpdateControlMapErrors];

export type GetUpdateControlMapResponses = {
  /**
   * Successful response.
   */
  200: UpdateControlMap;
};

export type GetUpdateControlMapResponse = GetUpdateControlMapResponses[keyof GetUpdateControlMapResponses];

export type DeploymentsInternalCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deployments/health';
};

export type DeploymentsInternalCheckHealthErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
  /**
   * Service unhealthy / not ready to accept traffic. At least one dependency is not running.
   *
   */
  503: _Error;
};

export type DeploymentsInternalCheckHealthError = DeploymentsInternalCheckHealthErrors[keyof DeploymentsInternalCheckHealthErrors];

export type DeploymentsInternalCheckHealthResponses = {
  /**
   * Service is healthy and all dependencies are up and running.
   *
   */
  204: void;
};

export type DeploymentsInternalCheckHealthResponse = DeploymentsInternalCheckHealthResponses[keyof DeploymentsInternalCheckHealthResponses];

export type DeploymentsInternalCheckLivelinessData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deployments/alive';
};

export type DeploymentsInternalCheckLivelinessErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsInternalCheckLivelinessError = DeploymentsInternalCheckLivelinessErrors[keyof DeploymentsInternalCheckLivelinessErrors];

export type DeploymentsInternalCheckLivelinessResponses = {
  /**
   * Service is up and running.
   */
  204: void;
};

export type DeploymentsInternalCheckLivelinessResponse = DeploymentsInternalCheckLivelinessResponses[keyof DeploymentsInternalCheckLivelinessResponses];

export type GetBinaryDeltaConfigurationsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deployments/tenants/config/binary_delta';
};

export type GetBinaryDeltaConfigurationsErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetBinaryDeltaConfigurationsError = GetBinaryDeltaConfigurationsErrors[keyof GetBinaryDeltaConfigurationsErrors];

export type GetBinaryDeltaConfigurationsResponses = {
  /**
   * Successful response with binary delta configurations.
   */
  200: Array<GetBinaryDeltaConfigurations200ResponseInner>;
};

export type GetBinaryDeltaConfigurationsResponse = GetBinaryDeltaConfigurationsResponses[keyof GetBinaryDeltaConfigurationsResponses];

export type GetStorageSettingsData = {
  body?: never;
  path: {
    /**
     * Tenant ID
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{id}/storage/settings';
};

export type GetStorageSettingsErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetStorageSettingsError = GetStorageSettingsErrors[keyof GetStorageSettingsErrors];

export type GetStorageSettingsResponses = {
  /**
   * Successful response with all available settings.
   */
  200: StorageSettings;
};

export type GetStorageSettingsResponse = GetStorageSettingsResponses[keyof GetStorageSettingsResponses];

export type SetStorageSettingsData = {
  /**
   * Settings to set.
   * If set to null or an empty object, the tenant will use the default settings.
   */
  body?: StorageSettings;
  path: {
    /**
     * Tenant ID
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{id}/storage/settings';
};

export type SetStorageSettingsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type SetStorageSettingsError = SetStorageSettingsErrors[keyof SetStorageSettingsErrors];

export type SetStorageSettingsResponses = {
  /**
   * Settings updated.
   */
  204: void;
};

export type SetStorageSettingsResponse = SetStorageSettingsResponses[keyof SetStorageSettingsResponses];

export type DeploymentsInternalGetStorageUsageData = {
  body?: never;
  path: {
    /**
     * Tenant ID
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{id}/limits/storage';
};

export type DeploymentsInternalGetStorageUsageErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsInternalGetStorageUsageError = DeploymentsInternalGetStorageUsageErrors[keyof DeploymentsInternalGetStorageUsageErrors];

export type DeploymentsInternalGetStorageUsageResponses = {
  /**
   * Successful response.
   */
  200: StorageUsage;
};

export type DeploymentsInternalGetStorageUsageResponse = DeploymentsInternalGetStorageUsageResponses[keyof DeploymentsInternalGetStorageUsageResponses];

export type SetStorageLimitData = {
  body: StorageLimit;
  path: {
    /**
     * Tenant ID
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{id}/limits/storage';
};

export type SetStorageLimitErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type SetStorageLimitError = SetStorageLimitErrors[keyof SetStorageLimitErrors];

export type SetStorageLimitResponses = {
  /**
   * Limit information updated.
   */
  204: void;
};

export type SetStorageLimitResponse = SetStorageLimitResponses[keyof SetStorageLimitResponses];

export type DeploymentsInternalCreateTenantData = {
  /**
   * New tenant descriptor.
   */
  body: TenantNew;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deployments/tenants';
};

export type DeploymentsInternalCreateTenantErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsInternalCreateTenantError = DeploymentsInternalCreateTenantErrors[keyof DeploymentsInternalCreateTenantErrors];

export type DeploymentsInternalCreateTenantResponses = {
  /**
   * Tenant was successfully provisioned.
   */
  201: unknown;
};

export type GetDeploymentsData = {
  body?: never;
  path: {
    /**
     * Tenant ID
     */
    id: string;
  };
  query?: {
    /**
     * Deployment status filter.
     */
    status?: 'inprogress' | 'finished' | 'pending';
    /**
     * Deployment name or description filter.
     */
    search?: string;
    /**
     * Results page number
     */
    page?: number;
    /**
     * List only deployments created before and equal to Unix timestamp (UTC)
     */
    created_before?: number;
    /**
     * List only deployments created after and equal to Unix timestamp (UTC)
     */
    created_after?: number;
  };
  url: '/api/internal/v1/deployments/tenants/{id}/deployments';
};

export type GetDeploymentsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
};

export type GetDeploymentsError = GetDeploymentsErrors[keyof GetDeploymentsErrors];

export type GetDeploymentsResponses = {
  /**
   * Successful response.
   */
  200: Array<DeploymentV1Internal>;
};

export type GetDeploymentsResponse = GetDeploymentsResponses[keyof GetDeploymentsResponses];

export type GetDeploymentGroupsData = {
  body?: never;
  path: {
    /**
     * Tenant ID
     */
    tenant_id: string;
    /**
     * Deployment identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{tenant_id}/deployments/{id}/groups';
};

export type GetDeploymentGroupsErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetDeploymentGroupsError = GetDeploymentGroupsErrors[keyof GetDeploymentGroupsErrors];

export type GetDeploymentGroupsResponses = {
  /**
   * Successful response.
   */
  200: DeviceGroups;
};

export type GetDeploymentGroupsResponse = GetDeploymentGroupsResponses[keyof GetDeploymentGroupsResponses];

export type DeleteTenantData = {
  body?: never;
  path: {
    /**
     * Tenant ID
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{id}';
};

export type DeleteTenantErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteTenantError = DeleteTenantErrors[keyof DeleteTenantErrors];

export type DeleteTenantResponses = {
  /**
   * Successful removal.
   */
  204: void;
};

export type DeleteTenantResponse = DeleteTenantResponses[keyof DeleteTenantResponses];

export type ListDeviceDeploymentsEntriesData = {
  body?: never;
  path: {
    /**
     * Tenant ID
     */
    tenant_id: string;
  };
  query?: {
    /**
     * Deployment Device ID filter. Can be repeated to query a set of entries.
     */
    id?: Array<string>;
  };
  url: '/api/internal/v1/deployments/tenants/{tenant_id}/deployments/devices';
};

export type ListDeviceDeploymentsEntriesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListDeviceDeploymentsEntriesError = ListDeviceDeploymentsEntriesErrors[keyof ListDeviceDeploymentsEntriesErrors];

export type ListDeviceDeploymentsEntriesResponses = {
  /**
   * OK
   */
  200: Array<DeviceDeployment>;
};

export type ListDeviceDeploymentsEntriesResponse = ListDeviceDeploymentsEntriesResponses[keyof ListDeviceDeploymentsEntriesResponses];

export type RemoveDeviceFromDeploymentsData = {
  body?: never;
  path: {
    /**
     * Tenant ID
     */
    tenant_id: string;
    /**
     * System wide device identifier
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{tenant_id}/deployments/devices/{id}';
};

export type RemoveDeviceFromDeploymentsErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type RemoveDeviceFromDeploymentsError = RemoveDeviceFromDeploymentsErrors[keyof RemoveDeviceFromDeploymentsErrors];

export type RemoveDeviceFromDeploymentsResponses = {
  /**
   * Device was removed
   */
  204: void;
};

export type RemoveDeviceFromDeploymentsResponse = RemoveDeviceFromDeploymentsResponses[keyof RemoveDeviceFromDeploymentsResponses];

export type DeploymentsInternalListDeploymentsForADeviceData = {
  body?: never;
  path: {
    /**
     * Tenant ID
     */
    tenant_id: string;
    /**
     * System wide device identifier
     */
    id: string;
  };
  query?: {
    /**
     * Filter deployments by status for the given device.
     */
    status?:
      | 'failure'
      | 'aborted'
      | 'pause_before_installing'
      | 'pause_before_committing'
      | 'pause_before_rebooting'
      | 'downloading'
      | 'installing'
      | 'rebooting'
      | 'pending'
      | 'success'
      | 'noartifact'
      | 'already-installed'
      | 'decommissioned'
      | 'pause'
      | 'active'
      | 'finished';
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/internal/v1/deployments/tenants/{tenant_id}/deployments/devices/{id}';
};

export type DeploymentsInternalListDeploymentsForADeviceErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsInternalListDeploymentsForADeviceError =
  DeploymentsInternalListDeploymentsForADeviceErrors[keyof DeploymentsInternalListDeploymentsForADeviceErrors];

export type DeploymentsInternalListDeploymentsForADeviceResponses = {
  /**
   * OK
   */
  200: Array<DeviceDeployment>;
};

export type DeploymentsInternalListDeploymentsForADeviceResponse =
  DeploymentsInternalListDeploymentsForADeviceResponses[keyof DeploymentsInternalListDeploymentsForADeviceResponses];

export type UploadArtifactData = {
  body: UploadArtifactRequest;
  path: {
    /**
     * Tenant ID, or "default" if running in non-multitenant setup
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{id}/artifacts';
};

export type UploadArtifactErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UploadArtifactError = UploadArtifactErrors[keyof UploadArtifactErrors];

export type UploadArtifactResponses = {
  /**
   * Artifact uploaded.
   */
  201: unknown;
};

export type DeploymentsInternalCreateDeploymentData = {
  /**
   * New deployment that needs to be created.
   */
  body: ConfigurationDeploymentRequest;
  path: {
    /**
     * Tenant identifier.
     */
    tenant_id: string;
    /**
     * Device identifier.
     */
    device_id: string;
    /**
     * Deployment identifier.
     */
    deployment_id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{tenant_id}/configuration/deployments/{deployment_id}/devices/{device_id}';
};

export type DeploymentsInternalCreateDeploymentErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsInternalCreateDeploymentError = DeploymentsInternalCreateDeploymentErrors[keyof DeploymentsInternalCreateDeploymentErrors];

export type DeploymentsInternalCreateDeploymentResponses = {
  /**
   * New configuration deployment created.
   */
  201: unknown;
};

export type GetTenantConfigurationData = {
  body?: never;
  path: {
    /**
     * Tenant identifier.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{tenant_id}/config';
};

export type GetTenantConfigurationErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetTenantConfigurationError = GetTenantConfigurationErrors[keyof GetTenantConfigurationErrors];

export type GetTenantConfigurationResponses = {
  /**
   * Successful response.
   */
  200: ConfigurationTenant;
};

export type GetTenantConfigurationResponse = GetTenantConfigurationResponses[keyof GetTenantConfigurationResponses];

export type UpdateTenantConfigurationData = {
  /**
   * Configuration update.
   */
  body: ConfigurationTenant;
  headers?: {
    /**
     * Contains the config' current ETag, and performs the update only if it matches the one stored in the database.
     */
    'If-Match'?: string;
  };
  path: {
    /**
     * Tenant identifier.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{tenant_id}/config';
};

export type UpdateTenantConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Document with a matching ETag does not exist.
   */
  412: unknown;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateTenantConfigurationError = UpdateTenantConfigurationErrors[keyof UpdateTenantConfigurationErrors];

export type UpdateTenantConfigurationResponses = {
  /**
   * Configuration updated.
   */
  204: void;
};

export type UpdateTenantConfigurationResponse = UpdateTenantConfigurationResponses[keyof UpdateTenantConfigurationResponses];

export type UpdateDeltaJobStatusData = {
  /**
   * New job status.
   */
  body: GenerateDeltaJobStatus;
  path: {
    /**
     * Tenant identifier.
     */
    tenant_id: string;
    /**
     * Job identifier.
     */
    job_id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{tenant_id}/delta/{job_id}/status';
};

export type UpdateDeltaJobStatusErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateDeltaJobStatusError = UpdateDeltaJobStatusErrors[keyof UpdateDeltaJobStatusErrors];

export type UpdateDeltaJobStatusResponses = {
  /**
   * Status updated sucessfully.
   */
  204: void;
};

export type UpdateDeltaJobStatusResponse = UpdateDeltaJobStatusResponses[keyof UpdateDeltaJobStatusResponses];

export type GetLastDeviceDeploymentStatusData = {
  body: LastDeviceDeploymentReq;
  path: {
    /**
     * Tenant identifier.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/deployments/tenants/{tenant_id}/devices/deployments/last';
};

export type GetLastDeviceDeploymentStatusErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetLastDeviceDeploymentStatusError = GetLastDeviceDeploymentStatusErrors[keyof GetLastDeviceDeploymentStatusErrors];

export type GetLastDeviceDeploymentStatusResponses = {
  /**
   * List of device deployment statuses returned.
   */
  200: LastDeviceDeploymentsStatuses;
};

export type GetLastDeviceDeploymentStatusResponse = GetLastDeviceDeploymentStatusResponses[keyof GetLastDeviceDeploymentStatusResponses];

export type DeploymentsV1ListDeploymentsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Deployment status filter.
     */
    status?: 'inprogress' | 'finished' | 'pending' | 'scheduled';
    /**
     * Deployment type filter.
     *
     */
    type?: 'software' | 'configuration';
    /**
     * Deployment name or description filter.
     */
    search?: string;
    /**
     * Results page number
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
    /**
     * List only deployments created before and equal to Unix timestamp (UTC)
     */
    created_before?: number;
    /**
     * List only deployments created after and equal to Unix timestamp (UTC)
     */
    created_after?: number;
    /**
     * Supports sorting the deployments list by creation date.
     *
     */
    sort?: 'asc' | 'desc';
  };
  url: '/api/management/v1/deployments/deployments';
};

export type DeploymentsV1ListDeploymentsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsV1ListDeploymentsError = DeploymentsV1ListDeploymentsErrors[keyof DeploymentsV1ListDeploymentsErrors];

export type DeploymentsV1ListDeploymentsResponses = {
  /**
   * Successful response.
   */
  200: Array<DeploymentV1>;
};

export type DeploymentsV1ListDeploymentsResponse = DeploymentsV1ListDeploymentsResponses[keyof DeploymentsV1ListDeploymentsResponses];

export type DeploymentsCreateDeploymentData = {
  /**
   * New deployment that needs to be created.
   */
  body: NewDeployment;
  path?: never;
  query?: never;
  url: '/api/management/v1/deployments/deployments';
};

export type DeploymentsCreateDeploymentErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * An active deployment with the same parameters already exists.
   */
  409: _Error;
  /**
   * Unprocessable Entity.
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsCreateDeploymentError = DeploymentsCreateDeploymentErrors[keyof DeploymentsCreateDeploymentErrors];

export type DeploymentsCreateDeploymentResponses = {
  /**
   * New deployment created.
   */
  201: unknown;
};

export type DeploymentStatusStatisticsListData = {
  body: DeploymentIdentifier;
  path?: never;
  query?: never;
  url: '/api/management/v1/deployments/deployments/statistics/list';
};

export type DeploymentStatusStatisticsListErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentStatusStatisticsListError = DeploymentStatusStatisticsListErrors[keyof DeploymentStatusStatisticsListErrors];

export type DeploymentStatusStatisticsListResponses = {
  /**
   * OK
   */
  200: Array<DeploymentStatusStatisticsList200ResponseInner>;
};

export type DeploymentStatusStatisticsListResponse = DeploymentStatusStatisticsListResponses[keyof DeploymentStatusStatisticsListResponses];

export type CreateDeploymentForAGroupOfDevicesData = {
  /**
   * New deployment that needs to be created.
   */
  body: NewDeploymentForGroup;
  path: {
    /**
     * Device group name.
     */
    name: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/group/{name}';
};

export type CreateDeploymentForAGroupOfDevicesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * An active deployment with the same parameters already exists.
   */
  409: _Error;
  /**
   * Unprocessable Entity.
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreateDeploymentForAGroupOfDevicesError = CreateDeploymentForAGroupOfDevicesErrors[keyof CreateDeploymentForAGroupOfDevicesErrors];

export type CreateDeploymentForAGroupOfDevicesResponses = {
  /**
   * New deployment created.
   */
  201: unknown;
};

export type ShowDeploymentData = {
  body?: never;
  path: {
    /**
     * Deployment identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/{id}';
};

export type ShowDeploymentErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowDeploymentError = ShowDeploymentErrors[keyof ShowDeploymentErrors];

export type ShowDeploymentResponses = {
  /**
   * Successful response.
   */
  200: DeploymentV1;
};

export type ShowDeploymentResponse = ShowDeploymentResponses[keyof ShowDeploymentResponses];

export type PatchDeploymentControlMapData = {
  /**
   * Update control map to set.
   */
  body: PatchDeploymentControlMapRequest;
  path: {
    /**
     * Deployment identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/{id}';
};

export type PatchDeploymentControlMapErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * An active deployment with the same parameters already exists.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type PatchDeploymentControlMapError = PatchDeploymentControlMapErrors[keyof PatchDeploymentControlMapErrors];

export type PatchDeploymentControlMapResponses = {
  /**
   * Control map updated.
   */
  204: void;
};

export type PatchDeploymentControlMapResponse = PatchDeploymentControlMapResponses[keyof PatchDeploymentControlMapResponses];

export type AbortDeploymentData = {
  /**
   * Deployment status.
   */
  body: AbortDeploymentRequest;
  path: {
    /**
     * Deployment identifier.
     */
    deployment_id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/{deployment_id}/status';
};

export type AbortDeploymentErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Unprocessable Entity.
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AbortDeploymentError = AbortDeploymentErrors[keyof AbortDeploymentErrors];

export type AbortDeploymentResponses = {
  /**
   * Status updated successfully.
   */
  204: void;
};

export type AbortDeploymentResponse = AbortDeploymentResponses[keyof AbortDeploymentResponses];

export type DeploymentStatusStatisticsData = {
  body?: never;
  path: {
    /**
     * Deployment identifier
     */
    deployment_id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/{deployment_id}/statistics';
};

export type DeploymentStatusStatisticsErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentStatusStatisticsError = DeploymentStatusStatisticsErrors[keyof DeploymentStatusStatisticsErrors];

export type DeploymentStatusStatisticsResponses = {
  /**
   * OK
   */
  200: Statistics;
};

export type DeploymentStatusStatisticsResponse = DeploymentStatusStatisticsResponses[keyof DeploymentStatusStatisticsResponses];

export type ListAllDevicesInDeploymentData = {
  body?: never;
  path: {
    /**
     * Deployment identifier.
     */
    deployment_id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/{deployment_id}/devices';
};

export type ListAllDevicesInDeploymentErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListAllDevicesInDeploymentError = ListAllDevicesInDeploymentErrors[keyof ListAllDevicesInDeploymentErrors];

export type ListAllDevicesInDeploymentResponses = {
  /**
   * OK
   */
  200: Array<DeviceWithImage>;
};

export type ListAllDevicesInDeploymentResponse = ListAllDevicesInDeploymentResponses[keyof ListAllDevicesInDeploymentResponses];

export type ListDevicesInDeploymentData = {
  body?: never;
  path: {
    /**
     * Deployment identifier.
     */
    deployment_id: string;
  };
  query?: {
    /**
     * Filter devices by status within deployment.
     */
    status?:
      | 'failure'
      | 'aborted'
      | 'pause_before_installing'
      | 'pause_before_committing'
      | 'pause_before_rebooting'
      | 'downloading'
      | 'installing'
      | 'rebooting'
      | 'pending'
      | 'success'
      | 'noartifact'
      | 'already-installed'
      | 'decommissioned'
      | 'pause'
      | 'active'
      | 'finished';
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v1/deployments/deployments/{deployment_id}/devices/list';
};

export type ListDevicesInDeploymentErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListDevicesInDeploymentError = ListDevicesInDeploymentErrors[keyof ListDevicesInDeploymentErrors];

export type ListDevicesInDeploymentResponses = {
  /**
   * OK
   */
  200: Array<DeviceWithImage>;
};

export type ListDevicesInDeploymentResponse = ListDevicesInDeploymentResponses[keyof ListDevicesInDeploymentResponses];

export type ListDeviceIdsInDeploymentData = {
  body?: never;
  path: {
    /**
     * Deployment identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/{id}/device_list';
};

export type ListDeviceIdsInDeploymentErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListDeviceIdsInDeploymentError = ListDeviceIdsInDeploymentErrors[keyof ListDeviceIdsInDeploymentErrors];

export type ListDeviceIdsInDeploymentResponses = {
  /**
   * List of device IDs
   */
  200: Array<string>;
};

export type ListDeviceIdsInDeploymentResponse = ListDeviceIdsInDeploymentResponses[keyof ListDeviceIdsInDeploymentResponses];

export type GetDeploymentLogForDeviceData = {
  body?: never;
  path: {
    /**
     * Deployment identifier.
     */
    deployment_id: string;
    /**
     * Device identifier.
     */
    device_id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/{deployment_id}/devices/{device_id}/log';
};

export type GetDeploymentLogForDeviceErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetDeploymentLogForDeviceError = GetDeploymentLogForDeviceErrors[keyof GetDeploymentLogForDeviceErrors];

export type GetDeploymentLogForDeviceResponses = {
  /**
   * Successful response, including the logs in text/plain format.
   */
  200: string;
};

export type GetDeploymentLogForDeviceResponse = GetDeploymentLogForDeviceResponses[keyof GetDeploymentLogForDeviceResponses];

export type GetDeltaGenerationStatusData = {
  body?: never;
  path: {
    /**
     * Deployment identifier.
     */
    deployment_id: string;
    /**
     * Device identifier.
     */
    device_id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/{deployment_id}/devices/{device_id}/delta/status';
};

export type GetDeltaGenerationStatusErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetDeltaGenerationStatusError = GetDeltaGenerationStatusErrors[keyof GetDeltaGenerationStatusErrors];

export type GetDeltaGenerationStatusResponses = {
  /**
   * Successful response, including the status in application/json format.
   */
  200: JobStatus;
};

export type GetDeltaGenerationStatusResponse = GetDeltaGenerationStatusResponses[keyof GetDeltaGenerationStatusResponses];

export type AbortDeploymentsForADeviceData = {
  body?: never;
  path: {
    /**
     * System wide device identifier
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/devices/{id}';
};

export type AbortDeploymentsForADeviceErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AbortDeploymentsForADeviceError = AbortDeploymentsForADeviceErrors[keyof AbortDeploymentsForADeviceErrors];

export type AbortDeploymentsForADeviceResponses = {
  /**
   * Operation completed successfully.
   */
  204: void;
};

export type AbortDeploymentsForADeviceResponse = AbortDeploymentsForADeviceResponses[keyof AbortDeploymentsForADeviceResponses];

export type DeploymentsListDeploymentsForADeviceData = {
  body?: never;
  path: {
    /**
     * System wide device identifier
     */
    id: string;
  };
  query?: {
    /**
     * Filter deployments by status for the given device.
     */
    status?:
      | 'failure'
      | 'aborted'
      | 'pause_before_installing'
      | 'pause_before_committing'
      | 'pause_before_rebooting'
      | 'downloading'
      | 'installing'
      | 'rebooting'
      | 'pending'
      | 'success'
      | 'noartifact'
      | 'already-installed'
      | 'decommissioned'
      | 'pause'
      | 'active'
      | 'finished';
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v1/deployments/deployments/devices/{id}';
};

export type DeploymentsListDeploymentsForADeviceErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsListDeploymentsForADeviceError = DeploymentsListDeploymentsForADeviceErrors[keyof DeploymentsListDeploymentsForADeviceErrors];

export type DeploymentsListDeploymentsForADeviceResponses = {
  /**
   * OK
   */
  200: Array<DeviceDeploymentV1>;
};

export type DeploymentsListDeploymentsForADeviceResponse = DeploymentsListDeploymentsForADeviceResponses[keyof DeploymentsListDeploymentsForADeviceResponses];

export type ResetDeviceDeploymentsHistoryData = {
  body?: never;
  path: {
    /**
     * System wide device identifier
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/deployments/devices/{id}/history';
};

export type ResetDeviceDeploymentsHistoryErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ResetDeviceDeploymentsHistoryError = ResetDeviceDeploymentsHistoryErrors[keyof ResetDeviceDeploymentsHistoryErrors];

export type ResetDeviceDeploymentsHistoryResponses = {
  /**
   * Operation completed successfully.
   */
  204: void;
};

export type ResetDeviceDeploymentsHistoryResponse = ResetDeviceDeploymentsHistoryResponses[keyof ResetDeviceDeploymentsHistoryResponses];

export type ListReleasesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Release name filter.
     */
    name?: string;
    /**
     * Release description filter.
     */
    description?: string;
    /**
     * Release device type filter.
     */
    device_type?: string;
    /**
     * Update type filter.
     */
    update_type?: string;
  };
  url: '/api/management/v1/deployments/deployments/releases';
};

export type ListReleasesErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListReleasesError = ListReleasesErrors[keyof ListReleasesErrors];

export type ListReleasesResponses = {
  /**
   * Successful response.
   */
  200: ReleasesV1;
};

export type ListReleasesResponse = ListReleasesResponses[keyof ListReleasesResponses];

export type DeploymentsV1ListReleasesWithPaginationData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Release name filter.
     */
    name?: string;
    /**
     * Release description filter.
     */
    description?: string;
    /**
     * Release device type filter.
     */
    device_type?: string;
    /**
     * Update type filter.
     */
    update_type?: string;
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
    /**
     * Sort the release list by the specified field and direction.
     *
     */
    sort?: 'artifacts_count:asc' | 'artifacts_count:desc' | 'modified:asc' | 'modified:desc' | 'name:asc' | 'name:desc' | 'tags:asc' | 'tags:desc';
  };
  url: '/api/management/v1/deployments/deployments/releases/list';
};

export type DeploymentsV1ListReleasesWithPaginationErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsV1ListReleasesWithPaginationError = DeploymentsV1ListReleasesWithPaginationErrors[keyof DeploymentsV1ListReleasesWithPaginationErrors];

export type DeploymentsV1ListReleasesWithPaginationResponses = {
  /**
   * Successful response.
   */
  200: ReleasesV1;
};

export type DeploymentsV1ListReleasesWithPaginationResponse =
  DeploymentsV1ListReleasesWithPaginationResponses[keyof DeploymentsV1ListReleasesWithPaginationResponses];

export type ListArtifactsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Release name filter.
     */
    name?: string;
    /**
     * Release description filter.
     */
    description?: string;
    /**
     * Release device type filter.
     */
    device_type?: string;
  };
  url: '/api/management/v1/deployments/artifacts';
};

export type ListArtifactsErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListArtifactsError = ListArtifactsErrors[keyof ListArtifactsErrors];

export type ListArtifactsResponses = {
  /**
   * OK
   */
  200: Array<ArtifactV1>;
};

export type ListArtifactsResponse = ListArtifactsResponses[keyof ListArtifactsResponses];

export type UploadArtifact2Data = {
  body: UploadArtifactRequest2;
  path?: never;
  query?: never;
  url: '/api/management/v1/deployments/artifacts';
};

export type UploadArtifact2Errors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * An artifact with the same name and matching dependency requirements already exists.
   *
   */
  409: ErrorExt;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UploadArtifact2Error = UploadArtifact2Errors[keyof UploadArtifact2Errors];

export type UploadArtifact2Responses = {
  /**
   * Artifact uploaded.
   */
  201: unknown;
};

export type DeploymentsV1ListArtifactsWithPaginationData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Artifact name filter.
     */
    name?: string;
    /**
     * Artifact description filter.
     */
    description?: string;
    /**
     * Artifact device type filter.
     */
    device_type?: string;
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
    /**
     * Sort the artifact list by the specified field and direction.
     *
     */
    sort?: 'name:asc' | 'name:desc' | 'modified:asc' | 'modified:desc';
  };
  url: '/api/management/v1/deployments/artifacts/list';
};

export type DeploymentsV1ListArtifactsWithPaginationErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsV1ListArtifactsWithPaginationError =
  DeploymentsV1ListArtifactsWithPaginationErrors[keyof DeploymentsV1ListArtifactsWithPaginationErrors];

export type DeploymentsV1ListArtifactsWithPaginationResponses = {
  /**
   * OK
   */
  200: Array<ArtifactV1>;
};

export type DeploymentsV1ListArtifactsWithPaginationResponse =
  DeploymentsV1ListArtifactsWithPaginationResponses[keyof DeploymentsV1ListArtifactsWithPaginationResponses];

export type RequestDirectUploadData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/deployments/artifacts/directupload';
};

export type RequestDirectUploadErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type RequestDirectUploadError = RequestDirectUploadErrors[keyof RequestDirectUploadErrors];

export type RequestDirectUploadResponses = {
  /**
   * OK
   */
  200: ArtifactUploadLink;
};

export type RequestDirectUploadResponse = RequestDirectUploadResponses[keyof RequestDirectUploadResponses];

export type CompleteDirectUploadData = {
  /**
   * Metadata for contents of the artifact.
   */
  body?: DirectUploadMetadata;
  path: {
    /**
     * Artifact ID returned by "Request Direct Upload" API.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/artifacts/directupload/{id}/complete';
};

export type CompleteDirectUploadErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * A pending direct upload with the given ID was not found.
   */
  404: CompleteDirectUpload404Response;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CompleteDirectUploadError = CompleteDirectUploadErrors[keyof CompleteDirectUploadErrors];

export type CompleteDirectUploadResponses = {
  /**
   * Accepted
   */
  202: unknown;
};

export type GenerateArtifactData = {
  body: GenerateArtifactRequest;
  path?: never;
  query?: never;
  url: '/api/management/v1/deployments/artifacts/generate';
};

export type GenerateArtifactErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GenerateArtifactError = GenerateArtifactErrors[keyof GenerateArtifactErrors];

export type GenerateArtifactResponses = {
  /**
   * Artifact generation request accepted and queued for processing.
   */
  201: unknown;
};

export type DeleteArtifactData = {
  body?: never;
  path: {
    /**
     * Artifact identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/artifacts/{id}';
};

export type DeleteArtifactErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Artifact used by active deployment.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteArtifactError = DeleteArtifactErrors[keyof DeleteArtifactErrors];

export type DeleteArtifactResponses = {
  /**
   * The artifact deleted successfully.
   */
  204: void;
};

export type DeleteArtifactResponse = DeleteArtifactResponses[keyof DeleteArtifactResponses];

export type ShowArtifactData = {
  body?: never;
  path: {
    /**
     * Artifact identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/artifacts/{id}';
};

export type ShowArtifactErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowArtifactError = ShowArtifactErrors[keyof ShowArtifactErrors];

export type ShowArtifactResponses = {
  /**
   * Successful response.
   */
  200: ArtifactV1;
};

export type ShowArtifactResponse = ShowArtifactResponses[keyof ShowArtifactResponses];

export type UpdateArtifactInfoData = {
  body?: ArtifactUpdateV1;
  path: {
    /**
     * Artifact identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/artifacts/{id}';
};

export type UpdateArtifactInfoErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Unprocessable Entity.
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateArtifactInfoError = UpdateArtifactInfoErrors[keyof UpdateArtifactInfoErrors];

export type UpdateArtifactInfoResponses = {
  /**
   * The artifact metadata updated successfully.
   */
  204: void;
};

export type UpdateArtifactInfoResponse = UpdateArtifactInfoResponses[keyof UpdateArtifactInfoResponses];

export type DownloadArtifactData = {
  body?: never;
  path: {
    /**
     * Artifact identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deployments/artifacts/{id}/download';
};

export type DownloadArtifactErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DownloadArtifactError = DownloadArtifactErrors[keyof DownloadArtifactErrors];

export type DownloadArtifactResponses = {
  /**
   * Successful response.
   */
  200: ArtifactLink;
};

export type DownloadArtifactResponse = DownloadArtifactResponses[keyof DownloadArtifactResponses];

export type DeploymentsGetStorageUsageData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/deployments/limits/storage';
};

export type DeploymentsGetStorageUsageErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsGetStorageUsageError = DeploymentsGetStorageUsageErrors[keyof DeploymentsGetStorageUsageErrors];

export type DeploymentsGetStorageUsageResponses = {
  /**
   * Successful response.
   */
  200: StorageLimit;
};

export type DeploymentsGetStorageUsageResponse = DeploymentsGetStorageUsageResponses[keyof DeploymentsGetStorageUsageResponses];

export type GetConfigurationData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/deployments/config';
};

export type GetConfigurationErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetConfigurationError = GetConfigurationErrors[keyof GetConfigurationErrors];

export type GetConfigurationResponses = {
  /**
   * Successful response.
   */
  200: ConfigurationTenant;
};

export type GetConfigurationResponse = GetConfigurationResponses[keyof GetConfigurationResponses];

export type UpdateBinaryDeltaConfigurationData = {
  /**
   * Binary Delta server-side generation configuration.
   */
  body: BinaryDeltaConfigurationUpdate;
  headers?: {
    /**
     * Contains the config current ETag, and performs the update only if it matches the one stored in the database.
     */
    'If-Match'?: string;
  };
  path?: never;
  query?: never;
  url: '/api/management/v1/deployments/config/binary_delta';
};

export type UpdateBinaryDeltaConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Delta generation is disabled.
   */
  409: _Error;
  /**
   * Document with a matching ETag does not exist.
   */
  412: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateBinaryDeltaConfigurationError = UpdateBinaryDeltaConfigurationErrors[keyof UpdateBinaryDeltaConfigurationErrors];

export type UpdateBinaryDeltaConfigurationResponses = {
  /**
   * Configuration updated.
   */
  204: void;
};

export type UpdateBinaryDeltaConfigurationResponse = UpdateBinaryDeltaConfigurationResponses[keyof UpdateBinaryDeltaConfigurationResponses];

export type DeploymentsV2ListDeploymentsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Deployment identifier. You can provide it multiple times to query a set of deployments.
     *
     */
    id?: string;
    /**
     * Deployment name. You can provide it multiple times to query a set of deployments.
     *
     */
    name?: string;
    /**
     * Deployment status filter.
     */
    status?: 'inprogress' | 'finished' | 'pending';
    /**
     * Deployment type filter.
     *
     */
    type?: 'software' | 'configuration';
    /**
     * Results page number
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
    /**
     * List only deployments created before and equal to Unix timestamp (UTC)
     */
    created_before?: number;
    /**
     * List only deployments created after and equal to Unix timestamp (UTC)
     */
    created_after?: number;
    /**
     * Supports sorting the deployments list by creation date.
     *
     */
    sort?: 'asc' | 'desc';
  };
  url: '/api/management/v2/deployments/deployments';
};

export type DeploymentsV2ListDeploymentsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsV2ListDeploymentsError = DeploymentsV2ListDeploymentsErrors[keyof DeploymentsV2ListDeploymentsErrors];

export type DeploymentsV2ListDeploymentsResponses = {
  /**
   * Successful response.
   */
  200: Array<DeploymentV2>;
};

export type DeploymentsV2ListDeploymentsResponse = DeploymentsV2ListDeploymentsResponses[keyof DeploymentsV2ListDeploymentsResponses];

export type CreateDeploymentData = {
  /**
   * New deployment that needs to be created.
   */
  body: NewDeploymentV2;
  path?: never;
  query?: never;
  url: '/api/management/v2/deployments/deployments';
};

export type CreateDeploymentErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * An active deployment with the same parameters already exists.
   */
  409: _Error;
  /**
   * Unprocessable Entity.
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreateDeploymentError = CreateDeploymentErrors[keyof CreateDeploymentErrors];

export type CreateDeploymentResponses = {
  /**
   * New deployment created.
   */
  201: unknown;
};

export type DeleteReleasesData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Name of the release to be deleted
     */
    name: string;
  };
  url: '/api/management/v2/deployments/deployments/releases';
};

export type DeleteReleasesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Conflict.
   */
  409: ReleasesDeleteError;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteReleasesError = DeleteReleasesErrors[keyof DeleteReleasesErrors];

export type DeleteReleasesResponses = {
  /**
   * Releases deleted successfully.
   */
  204: void;
};

export type DeleteReleasesResponse = DeleteReleasesResponses[keyof DeleteReleasesResponses];

export type DeploymentsV2ListReleasesWithPaginationData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Release name filter.
     */
    name?: string;
    /**
     * Tag filter.
     */
    tag?: Array<string>;
    /**
     * Update type filter.
     */
    update_type?: string;
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
    /**
     * Sort the release list by the specified field and direction.
     *
     */
    sort?: 'artifacts_count:asc' | 'artifacts_count:desc' | 'modified:asc' | 'modified:desc' | 'name:asc' | 'name:desc' | 'tags:asc' | 'tags:desc';
  };
  url: '/api/management/v2/deployments/deployments/releases';
};

export type DeploymentsV2ListReleasesWithPaginationErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsV2ListReleasesWithPaginationError = DeploymentsV2ListReleasesWithPaginationErrors[keyof DeploymentsV2ListReleasesWithPaginationErrors];

export type DeploymentsV2ListReleasesWithPaginationResponses = {
  /**
   * Successful response.
   */
  200: ReleasesV2;
};

export type DeploymentsV2ListReleasesWithPaginationResponse =
  DeploymentsV2ListReleasesWithPaginationResponses[keyof DeploymentsV2ListReleasesWithPaginationResponses];

export type GetReleaseWithGivenNameData = {
  body?: never;
  path: {
    /**
     * Name of the release
     */
    release_name: string;
  };
  query?: never;
  url: '/api/management/v2/deployments/deployments/releases/{release_name}';
};

export type GetReleaseWithGivenNameErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetReleaseWithGivenNameError = GetReleaseWithGivenNameErrors[keyof GetReleaseWithGivenNameErrors];

export type GetReleaseWithGivenNameResponses = {
  /**
   * Successful response.
   */
  200: ReleaseV2;
};

export type GetReleaseWithGivenNameResponse = GetReleaseWithGivenNameResponses[keyof GetReleaseWithGivenNameResponses];

export type UpdateReleaseInformationData = {
  body?: ReleaseUpdate;
  path: {
    /**
     * Name of the release
     */
    release_name: string;
  };
  query?: never;
  url: '/api/management/v2/deployments/deployments/releases/{release_name}';
};

export type UpdateReleaseInformationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateReleaseInformationError = UpdateReleaseInformationErrors[keyof UpdateReleaseInformationErrors];

export type UpdateReleaseInformationResponses = {
  /**
   * Successful response.
   */
  204: void;
};

export type UpdateReleaseInformationResponse = UpdateReleaseInformationResponses[keyof UpdateReleaseInformationResponses];

export type AssignReleaseTagsData = {
  body?: Tags;
  path: {
    /**
     * Name of the release
     */
    release_name: string;
  };
  query?: never;
  url: '/api/management/v2/deployments/deployments/releases/{release_name}/tags';
};

export type AssignReleaseTagsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Too many unique tag keys in use.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AssignReleaseTagsError = AssignReleaseTagsErrors[keyof AssignReleaseTagsErrors];

export type AssignReleaseTagsResponses = {
  /**
   * Successful response.
   */
  204: void;
};

export type AssignReleaseTagsResponse = AssignReleaseTagsResponses[keyof AssignReleaseTagsResponses];

export type ListReleaseTagsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v2/deployments/releases/all/tags';
};

export type ListReleaseTagsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Too many unique tag keys in use.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListReleaseTagsError = ListReleaseTagsErrors[keyof ListReleaseTagsErrors];

export type ListReleaseTagsResponses = {
  /**
   * Successful response.
   */
  200: Tags;
};

export type ListReleaseTagsResponse = ListReleaseTagsResponses[keyof ListReleaseTagsResponses];

export type ListReleaseTypesData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v2/deployments/releases/all/types';
};

export type ListReleaseTypesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListReleaseTypesError = ListReleaseTypesErrors[keyof ListReleaseTypesErrors];

export type ListReleaseTypesResponses = {
  /**
   * Successful response.
   */
  200: UpdateTypes;
};

export type ListReleaseTypesResponse = ListReleaseTypesResponses[keyof ListReleaseTypesResponses];

export type DeploymentsV2ListArtifactsWithPaginationData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Artifact(s) name(s) filter.
     * Multiple names can be provided (e.g., `?name=foo&name=bar`).
     * Supports exact matching or prefix matching by adding `*` to the end (e.g., `foo*`).
     * Note: when using prefix matching you may pass only a single value and you cannot combine
     * prefix matching and exact matching in the same request.
     *
     */
    name?: Array<string>;
    /**
     * Artifact description filter.
     * Supports exact matching or prefix matching by adding `*` to the end (e.g., `foo*`).
     *
     */
    description?: string;
    /**
     * Artifact device type filter.
     * Supports exact matching or prefix matching by adding `*` to the end (e.g., `foo*`).
     *
     */
    device_type?: string;
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v2/deployments/artifacts';
};

export type DeploymentsV2ListArtifactsWithPaginationErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeploymentsV2ListArtifactsWithPaginationError =
  DeploymentsV2ListArtifactsWithPaginationErrors[keyof DeploymentsV2ListArtifactsWithPaginationErrors];

export type DeploymentsV2ListArtifactsWithPaginationResponses = {
  /**
   * OK
   */
  200: Array<ArtifactV2>;
};

export type DeploymentsV2ListArtifactsWithPaginationResponse =
  DeploymentsV2ListArtifactsWithPaginationResponses[keyof DeploymentsV2ListArtifactsWithPaginationResponses];

export type ListServerSideBinaryDeltaGenerationJobsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
    /**
     * Sort the job list by the specified field and direction.
     *
     */
    sort?: 'status:asc' | 'status:desc' | 'started:asc' | 'started:desc' | 'to_version:asc' | 'to_version:desc' | 'from_version:asc' | 'from_version:desc';
  };
  url: '/api/management/v2/deployments/releases/delta/jobs';
};

export type ListServerSideBinaryDeltaGenerationJobsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListServerSideBinaryDeltaGenerationJobsError = ListServerSideBinaryDeltaGenerationJobsErrors[keyof ListServerSideBinaryDeltaGenerationJobsErrors];

export type ListServerSideBinaryDeltaGenerationJobsResponses = {
  /**
   * Succesful query
   */
  200: Array<DeltaJobsListItem>;
};

export type ListServerSideBinaryDeltaGenerationJobsResponse =
  ListServerSideBinaryDeltaGenerationJobsResponses[keyof ListServerSideBinaryDeltaGenerationJobsResponses];

export type GetServerSideBinaryDeltaGenerationJobDetailsData = {
  body?: never;
  path: {
    /**
     * Delta generation job id
     *
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/deployments/releases/delta/jobs/{id}';
};

export type GetServerSideBinaryDeltaGenerationJobDetailsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetServerSideBinaryDeltaGenerationJobDetailsError =
  GetServerSideBinaryDeltaGenerationJobDetailsErrors[keyof GetServerSideBinaryDeltaGenerationJobDetailsErrors];

export type GetServerSideBinaryDeltaGenerationJobDetailsResponses = {
  /**
   * Successful response.
   */
  200: DeltaJobDetailsItem;
};

export type GetServerSideBinaryDeltaGenerationJobDetailsResponse =
  GetServerSideBinaryDeltaGenerationJobDetailsResponses[keyof GetServerSideBinaryDeltaGenerationJobDetailsResponses];

export type DeviceAuthAuthenticateDeviceData = {
  body: AuthRequest;
  headers: {
    /**
     * Request signature.
     * The request signature depends on the public key submitted in the AuthRequest.
     * A summary of signature algorithms and format follows:
     * | Type       | Digest              | Format                   | Algorithm    |
     * |------------|---------------------|--------------------------|--------------|
     * | RSA        | SHA256(AuthRequest) | Base64(Signature)        | [RFC2313]    |
     * | ECDSA      | SHA256(AuthRequest) | Base64(ASN.1(SEQ{R, S})) | [ANSI x9.62] |
     * | Ed25519    | AuthRequest         | Base64(Signature)        | [RFC8032]    |
     * *Remark:*
     * For ECDSA, the signature constitutes two integers (R and S)
     * in which case the binary signature is taken as the ASN.1 sequence of
     * the two numbers in the given order.
     *
     */
    'X-MEN-Signature': string;
  };
  path?: never;
  query?: never;
  url: '/api/devices/v1/authentication/auth_requests';
};

export type DeviceAuthAuthenticateDeviceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The device authentication is forbidden. See the error message for details.
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthAuthenticateDeviceError = DeviceAuthAuthenticateDeviceErrors[keyof DeviceAuthAuthenticateDeviceErrors];

export type DeviceAuthAuthenticateDeviceResponses = {
  /**
   * Authentication successful - a new JWT is issued and returned.
   */
  200: string;
};

export type DeviceAuthAuthenticateDeviceResponse = DeviceAuthAuthenticateDeviceResponses[keyof DeviceAuthAuthenticateDeviceResponses];

export type DeviceAuthInternalCheckLivelinessData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/devauth/alive';
};

export type DeviceAuthInternalCheckLivelinessErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalCheckLivelinessError = DeviceAuthInternalCheckLivelinessErrors[keyof DeviceAuthInternalCheckLivelinessErrors];

export type DeviceAuthInternalCheckLivelinessResponses = {
  /**
   * Service is up and running
   */
  204: void;
};

export type DeviceAuthInternalCheckLivelinessResponse = DeviceAuthInternalCheckLivelinessResponses[keyof DeviceAuthInternalCheckLivelinessResponses];

export type DeviceAuthInternalCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/devauth/health';
};

export type DeviceAuthInternalCheckHealthErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
  /**
   * Service unhealthy / not ready to accept traffic. At least one dependency is not running.
   */
  503: _Error;
};

export type DeviceAuthInternalCheckHealthError = DeviceAuthInternalCheckHealthErrors[keyof DeviceAuthInternalCheckHealthErrors];

export type DeviceAuthInternalCheckHealthResponses = {
  /**
   * Service is healthy and all dependencies are up and running.
   */
  204: void;
};

export type DeviceAuthInternalCheckHealthResponse = DeviceAuthInternalCheckHealthResponses[keyof DeviceAuthInternalCheckHealthResponses];

export type DeviceAuthInternalVerifyJwtData = {
  body?: never;
  headers: {
    /**
     * The token in base64-encoded form.
     */
    Authorization: string;
  };
  path?: never;
  query?: never;
  url: '/api/internal/v1/devauth/tokens/verify';
};

export type DeviceAuthInternalVerifyJwtErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalVerifyJwtError = DeviceAuthInternalVerifyJwtErrors[keyof DeviceAuthInternalVerifyJwtErrors];

export type DeviceAuthInternalVerifyJwtResponses = {
  /**
   * The token is valid.
   */
  200: unknown;
};

export type DeviceAuthInternalRevokeDeviceTokensData = {
  body?: never;
  path?: never;
  query: {
    tenant_id: string;
    device_id?: string;
  };
  url: '/api/internal/v1/devauth/tokens';
};

export type DeviceAuthInternalRevokeDeviceTokensErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalRevokeDeviceTokensError = DeviceAuthInternalRevokeDeviceTokensErrors[keyof DeviceAuthInternalRevokeDeviceTokensErrors];

export type DeviceAuthInternalRevokeDeviceTokensResponses = {
  /**
   * Tokens deleted.
   */
  204: void;
};

export type DeviceAuthInternalRevokeDeviceTokensResponse = DeviceAuthInternalRevokeDeviceTokensResponses[keyof DeviceAuthInternalRevokeDeviceTokensResponses];

export type GetDeviceLimitsData = {
  body?: never;
  path: {
    /**
     * Limit identifier.
     */
    name: 'max_devices' | 'max_micro_devices' | 'max_system_devices';
  };
  query: {
    /**
     * Tenant ID.
     */
    tenant_id: Array<string>;
  };
  url: '/api/internal/v1/devauth/tenant/limits/{name}';
};

export type GetDeviceLimitsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetDeviceLimitsError = GetDeviceLimitsErrors[keyof GetDeviceLimitsErrors];

export type GetDeviceLimitsResponses = {
  /**
   * Successful response.
   */
  200: Array<TenantLimit>;
};

export type GetDeviceLimitsResponse = GetDeviceLimitsResponses[keyof GetDeviceLimitsResponses];

export type DeviceAuthInternalClearDeviceLimitData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
    /**
     * Limit identifier.
     */
    name: 'max_devices' | 'max_micro_devices' | 'max_system_devices';
  };
  query?: never;
  url: '/api/internal/v1/devauth/tenant/{tenant_id}/limits/{name}';
};

export type DeviceAuthInternalClearDeviceLimitErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalClearDeviceLimitError = DeviceAuthInternalClearDeviceLimitErrors[keyof DeviceAuthInternalClearDeviceLimitErrors];

export type DeviceAuthInternalClearDeviceLimitResponses = {
  /**
   * Limit information deleted.
   */
  204: void;
};

export type DeviceAuthInternalClearDeviceLimitResponse = DeviceAuthInternalClearDeviceLimitResponses[keyof DeviceAuthInternalClearDeviceLimitResponses];

export type DeviceAuthInternalGetDeviceLimitData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
    /**
     * Limit identifier.
     */
    name: 'max_devices' | 'max_micro_devices' | 'max_system_devices';
  };
  query?: never;
  url: '/api/internal/v1/devauth/tenant/{tenant_id}/limits/{name}';
};

export type DeviceAuthInternalGetDeviceLimitErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalGetDeviceLimitError = DeviceAuthInternalGetDeviceLimitErrors[keyof DeviceAuthInternalGetDeviceLimitErrors];

export type DeviceAuthInternalGetDeviceLimitResponses = {
  /**
   * Successful response.
   */
  200: DeviceLimit;
};

export type DeviceAuthInternalGetDeviceLimitResponse = DeviceAuthInternalGetDeviceLimitResponses[keyof DeviceAuthInternalGetDeviceLimitResponses];

export type DeviceAuthInternalUpdateDeviceLimitData = {
  body: DeviceLimit;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
    /**
     * Limit identifier.
     */
    name: 'max_devices' | 'max_micro_devices' | 'max_system_devices';
  };
  query?: never;
  url: '/api/internal/v1/devauth/tenant/{tenant_id}/limits/{name}';
};

export type DeviceAuthInternalUpdateDeviceLimitErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalUpdateDeviceLimitError = DeviceAuthInternalUpdateDeviceLimitErrors[keyof DeviceAuthInternalUpdateDeviceLimitErrors];

export type DeviceAuthInternalUpdateDeviceLimitResponses = {
  /**
   * Limit information updated.
   */
  204: void;
};

export type DeviceAuthInternalUpdateDeviceLimitResponse = DeviceAuthInternalUpdateDeviceLimitResponses[keyof DeviceAuthInternalUpdateDeviceLimitResponses];

export type DeviceAuthInternalCreateTenantData = {
  body: TenantNew;
  path?: never;
  query?: never;
  url: '/api/internal/v1/devauth/tenants';
};

export type DeviceAuthInternalCreateTenantErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalCreateTenantError = DeviceAuthInternalCreateTenantErrors[keyof DeviceAuthInternalCreateTenantErrors];

export type DeviceAuthInternalCreateTenantResponses = {
  /**
   * Tenant was successfully provisioned.
   */
  201: unknown;
};

export type DeviceAuthInternalDeleteDeviceData = {
  body?: never;
  headers?: {
    /**
     * The token in base64-encoded form.
     */
    authorization?: string;
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path: {
    tid: string;
    did: string;
  };
  query?: never;
  url: '/api/internal/v1/devauth/tenants/{tid}/devices/{did}';
};

export type DeviceAuthInternalDeleteDeviceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalDeleteDeviceError = DeviceAuthInternalDeleteDeviceErrors[keyof DeviceAuthInternalDeleteDeviceErrors];

export type DeviceAuthInternalDeleteDeviceResponses = {
  /**
   * Device deleted successfully.
   */
  201: unknown;
};

export type DeviceAuthInternalSetExternalIdentityData = {
  body: ExternalDevice;
  path: {
    /**
     * Tenant identifier.
     */
    tid: string;
    /**
     * Device identifier.
     */
    did: string;
  };
  query?: never;
  url: '/api/internal/v1/devauth/tenants/{tid}/devices/{did}/external';
};

export type DeviceAuthInternalSetExternalIdentityErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalSetExternalIdentityError = DeviceAuthInternalSetExternalIdentityErrors[keyof DeviceAuthInternalSetExternalIdentityErrors];

export type DeviceAuthInternalSetExternalIdentityResponses = {
  /**
   * Device identity updated successfully.
   */
  204: void;
};

export type DeviceAuthInternalSetExternalIdentityResponse =
  DeviceAuthInternalSetExternalIdentityResponses[keyof DeviceAuthInternalSetExternalIdentityResponses];

export type DeleteTenant2Data = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tid: string;
  };
  query?: never;
  url: '/api/internal/v1/devauth/tenants/{tid}';
};

export type DeleteTenant2Errors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteTenant2Error = DeleteTenant2Errors[keyof DeleteTenant2Errors];

export type DeleteTenant2Responses = {
  /**
   * All the tenant data have been successfully deleted.
   */
  204: void;
};

export type DeleteTenant2Response = DeleteTenant2Responses[keyof DeleteTenant2Responses];

export type DeviceAuthInternalDeviceStatusData = {
  body?: never;
  path: {
    /**
     * Tenant identifier.
     */
    tid: string;
    /**
     * Device identifier.
     */
    did: string;
  };
  query?: never;
  url: '/api/internal/v1/devauth/tenants/{tid}/devices/{did}/status';
};

export type DeviceAuthInternalDeviceStatusErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalDeviceStatusError = DeviceAuthInternalDeviceStatusErrors[keyof DeviceAuthInternalDeviceStatusErrors];

export type DeviceAuthInternalDeviceStatusResponses = {
  /**
   * Success.
   */
  200: Status;
};

export type DeviceAuthInternalDeviceStatusResponse = DeviceAuthInternalDeviceStatusResponses[keyof DeviceAuthInternalDeviceStatusResponses];

export type DeviceAuthInternalListDevicesData = {
  body?: never;
  path: {
    /**
     * Tenant identifier.
     */
    tid: string;
  };
  query?: {
    /**
     * Device status filter. If not specified, all devices are listed.
     */
    status?: 'pending' | 'accepted' | 'rejected' | 'preauthorized' | 'noauth';
    /**
     * Device ID filter. Can be repeated to query a set of devices.
     */
    id?: Array<string>;
    /**
     * Results page number.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/internal/v1/devauth/tenants/{tid}/devices';
};

export type DeviceAuthInternalListDevicesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalListDevicesError = DeviceAuthInternalListDevicesErrors[keyof DeviceAuthInternalListDevicesErrors];

export type DeviceAuthInternalListDevicesResponses = {
  /**
   * An array of devices.
   */
  200: Array<Device>;
};

export type DeviceAuthInternalListDevicesResponse = DeviceAuthInternalListDevicesResponses[keyof DeviceAuthInternalListDevicesResponses];

export type DeviceAuthInternalCountDevicesData = {
  body?: never;
  path: {
    /**
     * Tenant identifier.
     */
    tid: string;
  };
  query?: {
    /**
     * Device status filter, one of 'pending', 'accepted', 'rejected', 'noauth'. Default is 'all devices'.
     */
    status?: string;
  };
  url: '/api/internal/v1/devauth/tenants/{tid}/devices/count';
};

export type DeviceAuthInternalCountDevicesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthInternalCountDevicesError = DeviceAuthInternalCountDevicesErrors[keyof DeviceAuthInternalCountDevicesErrors];

export type DeviceAuthInternalCountDevicesResponses = {
  /**
   * Device count.
   */
  200: Count;
};

export type DeviceAuthInternalCountDevicesResponse = DeviceAuthInternalCountDevicesResponses[keyof DeviceAuthInternalCountDevicesResponses];

export type DeviceAuthManagementListDevicesData = {
  body?: never;
  headers?: {
    /**
     * The token in base64-encoded form.
     */
    authorization?: string;
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path?: never;
  query?: {
    /**
     * Device status filter. If not specified, all devices are listed.
     */
    status?: 'pending' | 'accepted' | 'rejected' | 'preauthorized' | 'noauth';
    /**
     * Device ID filter. Can be repeated to query a set of devices.
     */
    id?: Array<string>;
    /**
     * Results page number
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v2/devauth/devices';
};

export type DeviceAuthManagementListDevicesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementListDevicesError = DeviceAuthManagementListDevicesErrors[keyof DeviceAuthManagementListDevicesErrors];

export type DeviceAuthManagementListDevicesResponses = {
  /**
   * An array of devices.
   */
  200: Array<Device>;
};

export type DeviceAuthManagementListDevicesResponse = DeviceAuthManagementListDevicesResponses[keyof DeviceAuthManagementListDevicesResponses];

export type DeviceAuthManagementPreauthorizeData = {
  body: PreAuthSet;
  headers?: {
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path?: never;
  query?: never;
  url: '/api/management/v2/devauth/devices';
};

export type DeviceAuthManagementPreauthorizeErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Device already exists. Response contains conflicting device.
   */
  409: Device;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementPreauthorizeError = DeviceAuthManagementPreauthorizeErrors[keyof DeviceAuthManagementPreauthorizeErrors];

export type DeviceAuthManagementPreauthorizeResponses = {
  /**
   * Device submitted.
   */
  201: unknown;
};

export type DeviceAuthManagementSearchDevicesData = {
  /**
   * Device status filter. All properties can be either a single string or an array of strings.
   */
  body: {
    /**
     * Device status filter. Can be an array for querying devices from multiple device statuses.
     */
    status?: Array<'pending' | 'accepted' | 'rejected' | 'preauthorized' | 'noauth'>;
    /**
     * Device ID filter. Can be a string for querying for a single device.
     */
    id?: Array<string>;
  };
  headers?: {
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path?: never;
  query?: {
    /**
     * Results page number
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v2/devauth/devices/search';
};

export type DeviceAuthManagementSearchDevicesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementSearchDevicesError = DeviceAuthManagementSearchDevicesErrors[keyof DeviceAuthManagementSearchDevicesErrors];

export type DeviceAuthManagementSearchDevicesResponses = {
  /**
   * Array of devices
   */
  200: Array<Device>;
};

export type DeviceAuthManagementSearchDevicesResponse = DeviceAuthManagementSearchDevicesResponses[keyof DeviceAuthManagementSearchDevicesResponses];

export type DeviceAuthManagementDecommissionDeviceData = {
  body?: never;
  headers?: {
    /**
     * The token in base64-encoded form.
     */
    Authorization?: string;
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path: {
    /**
     * Device identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/devauth/devices/{id}';
};

export type DeviceAuthManagementDecommissionDeviceErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementDecommissionDeviceError = DeviceAuthManagementDecommissionDeviceErrors[keyof DeviceAuthManagementDecommissionDeviceErrors];

export type DeviceAuthManagementDecommissionDeviceResponses = {
  /**
   * Device decommissioned.
   */
  204: void;
};

export type DeviceAuthManagementDecommissionDeviceResponse =
  DeviceAuthManagementDecommissionDeviceResponses[keyof DeviceAuthManagementDecommissionDeviceResponses];

export type DeviceAuthManagementGetDeviceData = {
  body?: never;
  headers?: {
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
    /**
     * The token in base64-encoded form.
     */
    authorization?: string;
  };
  path: {
    /**
     * Device identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/devauth/devices/{id}';
};

export type DeviceAuthManagementGetDeviceErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementGetDeviceError = DeviceAuthManagementGetDeviceErrors[keyof DeviceAuthManagementGetDeviceErrors];

export type DeviceAuthManagementGetDeviceResponses = {
  /**
   * Device found.
   */
  200: Device;
};

export type DeviceAuthManagementGetDeviceResponse = DeviceAuthManagementGetDeviceResponses[keyof DeviceAuthManagementGetDeviceResponses];

export type DeviceAuthManagementRemoveAuthenticationData = {
  body?: never;
  headers?: {
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
    /**
     * The token in base64-encoded form.
     */
    authorization?: string;
  };
  path: {
    /**
     * Device identifier.
     */
    id: string;
    /**
     * Authentication data set identifier.
     */
    aid: string;
  };
  query?: never;
  url: '/api/management/v2/devauth/devices/{id}/auth/{aid}';
};

export type DeviceAuthManagementRemoveAuthenticationErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementRemoveAuthenticationError =
  DeviceAuthManagementRemoveAuthenticationErrors[keyof DeviceAuthManagementRemoveAuthenticationErrors];

export type DeviceAuthManagementRemoveAuthenticationResponses = {
  /**
   * Device authentication set deleted.
   */
  204: void;
};

export type DeviceAuthManagementRemoveAuthenticationResponse =
  DeviceAuthManagementRemoveAuthenticationResponses[keyof DeviceAuthManagementRemoveAuthenticationResponses];

export type DeviceAuthManagementGetAuthenticationStatusData = {
  body?: never;
  headers?: {
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path: {
    /**
     * Device identifier.
     */
    id: string;
    /**
     * Authentication data set identifier.
     */
    aid: string;
  };
  query?: never;
  url: '/api/management/v2/devauth/devices/{id}/auth/{aid}/status';
};

export type DeviceAuthManagementGetAuthenticationStatusErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementGetAuthenticationStatusError =
  DeviceAuthManagementGetAuthenticationStatusErrors[keyof DeviceAuthManagementGetAuthenticationStatusErrors];

export type DeviceAuthManagementGetAuthenticationStatusResponses = {
  /**
   * Successful response - the device's authentication set status is returned.
   */
  200: Status;
};

export type DeviceAuthManagementGetAuthenticationStatusResponse =
  DeviceAuthManagementGetAuthenticationStatusResponses[keyof DeviceAuthManagementGetAuthenticationStatusResponses];

export type DeviceAuthManagementSetAuthenticationStatusData = {
  body: Status;
  headers?: {
    /**
     * The token in base64-encoded form.
     */
    authorization?: string;
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path: {
    /**
     * Device identifier.
     */
    id: string;
    /**
     * Authentication data set identifier.
     */
    aid: string;
  };
  query?: never;
  url: '/api/management/v2/devauth/devices/{id}/auth/{aid}/status';
};

export type DeviceAuthManagementSetAuthenticationStatusErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Request cannot be fulfilled e.g. due to exceeded limit on maximum accepted devices (see error message).
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementSetAuthenticationStatusError =
  DeviceAuthManagementSetAuthenticationStatusErrors[keyof DeviceAuthManagementSetAuthenticationStatusErrors];

export type DeviceAuthManagementSetAuthenticationStatusResponses = {
  /**
   * The device authentication data set status was successfully updated.
   */
  204: void;
};

export type DeviceAuthManagementSetAuthenticationStatusResponse =
  DeviceAuthManagementSetAuthenticationStatusResponses[keyof DeviceAuthManagementSetAuthenticationStatusResponses];

export type DeviceAuthManagementCountDevicesData = {
  body?: never;
  headers?: {
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path?: never;
  query?: {
    /**
     * Device status filter, one of 'pending', 'accepted', 'rejected', 'noauth', 'preauthorized'. Default is 'all devices', meaning devices with any of these statuses will be counted.
     */
    status?: string;
  };
  url: '/api/management/v2/devauth/devices/count';
};

export type DeviceAuthManagementCountDevicesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementCountDevicesError = DeviceAuthManagementCountDevicesErrors[keyof DeviceAuthManagementCountDevicesErrors];

export type DeviceAuthManagementCountDevicesResponses = {
  /**
   * Device count.
   */
  200: Count;
};

export type DeviceAuthManagementCountDevicesResponse = DeviceAuthManagementCountDevicesResponses[keyof DeviceAuthManagementCountDevicesResponses];

export type DeviceAuthManagementRevokeApiTokenData = {
  body?: never;
  headers?: {
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path: {
    /**
     * Unique token identifier('jti').
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/devauth/tokens/{id}';
};

export type DeviceAuthManagementRevokeApiTokenErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementRevokeApiTokenError = DeviceAuthManagementRevokeApiTokenErrors[keyof DeviceAuthManagementRevokeApiTokenErrors];

export type DeviceAuthManagementRevokeApiTokenResponses = {
  /**
   * The token was successfully deleted.
   */
  204: void;
};

export type DeviceAuthManagementRevokeApiTokenResponse = DeviceAuthManagementRevokeApiTokenResponses[keyof DeviceAuthManagementRevokeApiTokenResponses];

export type DeviceAuthManagementGetDeviceLimitData = {
  body?: never;
  headers?: {
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path: {
    /**
     * Limit identifier.
     */
    name: 'max_devices' | 'max_micro_devices' | 'max_system_devices';
  };
  query?: never;
  url: '/api/management/v2/devauth/limits/{name}';
};

export type DeviceAuthManagementGetDeviceLimitErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAuthManagementGetDeviceLimitError = DeviceAuthManagementGetDeviceLimitErrors[keyof DeviceAuthManagementGetDeviceLimitErrors];

export type DeviceAuthManagementGetDeviceLimitResponses = {
  /**
   * Usage statistics and limits.
   */
  200: DeviceLimit;
};

export type DeviceAuthManagementGetDeviceLimitResponse = DeviceAuthManagementGetDeviceLimitResponses[keyof DeviceAuthManagementGetDeviceLimitResponses];

export type GetDeviceLimitsPerTierData = {
  body?: never;
  headers?: {
    /**
     * A request identification
     */
    'X-MEN-RequestID'?: string;
  };
  path?: never;
  query?: never;
  url: '/api/management/v2/devauth/limits/devices';
};

export type GetDeviceLimitsPerTierErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetDeviceLimitsPerTierError = GetDeviceLimitsPerTierErrors[keyof GetDeviceLimitsPerTierErrors];

export type GetDeviceLimitsPerTierResponses = {
  /**
   * Usage statistics and limits.
   */
  200: DeviceTierLimits;
};

export type GetDeviceLimitsPerTierResponse = GetDeviceLimitsPerTierResponses[keyof GetDeviceLimitsPerTierResponses];

export type GetDeviceLicenseData = {
  body?: never;
  headers?: {
    /**
     * The token in base64-encoded form.
     */
    authorization?: string;
  };
  path?: never;
  query?: never;
  url: '/api/management/v2/devauth/license';
};

export type GetDeviceLicenseErrors = {
  /**
   * Not Found.
   */
  404: _Error;
};

export type GetDeviceLicenseError = GetDeviceLicenseErrors[keyof GetDeviceLicenseErrors];

export type GetDeviceLicenseResponses = {
  /**
   * UsageStatistics
   *
   * Usage statistics and limits.
   */
  200: string;
};

export type GetDeviceLicenseResponse = GetDeviceLicenseResponses[keyof GetDeviceLicenseResponses];

export type AutomaticallyAuthenticateDeviceData = {
  body: AutoAuthRequest;
  headers: {
    /**
     * Request signature.
     *
     * The request signature depends on the public key submitted in the
     * AuthRequest. A summary of signature algorithms and format follows:
     *
     * | Type       | Digest              | Format                   | Algorithm    |
     * |------------|---------------------|--------------------------|--------------|
     * | RSA        | SHA256(AuthRequest) | Base64(Signature)        | [RFC2313]    |
     * | ECDSA      | SHA256(AuthRequest) | Base64(ASN.1(SEQ{R, S})) | [ANSI x9.62] |
     * | ED25519    | AuthRequest         | Base64(Signature)        | [RFC8032]    |
     * *Remark:*
     * For ECDSA, the signature constitutes two integers (R and S)
     * in which case the binary signature is taken as the ASN.1 sequence of
     * the two numbers in the given order.
     *
     */
    'X-MEN-Signature': string;
  };
  path?: never;
  query?: never;
  url: '/api/management/v2/devauth/auto-auth';
};

export type AutomaticallyAuthenticateDeviceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AutomaticallyAuthenticateDeviceError = AutomaticallyAuthenticateDeviceErrors[keyof AutomaticallyAuthenticateDeviceErrors];

export type AutomaticallyAuthenticateDeviceResponses = {
  /**
   * Authentication successful - a new JWT is issued and returned.
   */
  200: string;
};

export type AutomaticallyAuthenticateDeviceResponse = AutomaticallyAuthenticateDeviceResponses[keyof AutomaticallyAuthenticateDeviceResponses];

export type DeviceConfigGetDeviceConfigurationData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/devices/v1/deviceconfig/configuration';
};

export type DeviceConfigGetDeviceConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigGetDeviceConfigurationError = DeviceConfigGetDeviceConfigurationErrors[keyof DeviceConfigGetDeviceConfigurationErrors];

export type DeviceConfigGetDeviceConfigurationResponses = {
  /**
   * OK
   */
  200: DeviceApiConfiguration;
};

export type DeviceConfigGetDeviceConfigurationResponse = DeviceConfigGetDeviceConfigurationResponses[keyof DeviceConfigGetDeviceConfigurationResponses];

export type DeviceConfigReportDeviceConfigurationData = {
  body?: DeviceApiConfiguration;
  path?: never;
  query?: never;
  url: '/api/devices/v1/deviceconfig/configuration';
};

export type DeviceConfigReportDeviceConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigReportDeviceConfigurationError = DeviceConfigReportDeviceConfigurationErrors[keyof DeviceConfigReportDeviceConfigurationErrors];

export type DeviceConfigReportDeviceConfigurationResponses = {
  /**
   * Created
   */
  204: void;
};

export type DeviceConfigReportDeviceConfigurationResponse =
  DeviceConfigReportDeviceConfigurationResponses[keyof DeviceConfigReportDeviceConfigurationResponses];

export type DeviceConfigInternalCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deviceconfig/health';
};

export type DeviceConfigInternalCheckHealthErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigInternalCheckHealthError = DeviceConfigInternalCheckHealthErrors[keyof DeviceConfigInternalCheckHealthErrors];

export type DeviceConfigInternalCheckHealthResponses = {
  /**
   * Service is healthy.
   */
  204: void;
};

export type DeviceConfigInternalCheckHealthResponse = DeviceConfigInternalCheckHealthResponses[keyof DeviceConfigInternalCheckHealthResponses];

export type DeviceConfigInternalCheckLivelinessData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deviceconfig/alive';
};

export type DeviceConfigInternalCheckLivelinessErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigInternalCheckLivelinessError = DeviceConfigInternalCheckLivelinessErrors[keyof DeviceConfigInternalCheckLivelinessErrors];

export type DeviceConfigInternalCheckLivelinessResponses = {
  /**
   * Service is up and serving requests.
   */
  204: void;
};

export type DeviceConfigInternalCheckLivelinessResponse = DeviceConfigInternalCheckLivelinessResponses[keyof DeviceConfigInternalCheckLivelinessResponses];

export type DeviceConfigInternalProvisionTenantData = {
  body?: TenantNew;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deviceconfig/tenants';
};

export type DeviceConfigInternalProvisionTenantErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigInternalProvisionTenantError = DeviceConfigInternalProvisionTenantErrors[keyof DeviceConfigInternalProvisionTenantErrors];

export type DeviceConfigInternalProvisionTenantResponses = {
  /**
   * Tenant initialized successfully.
   */
  201: unknown;
};

export type DeviceConfigInternalDeleteTenantData = {
  body?: never;
  path: {
    /**
     * ID of tenant.
     */
    tenantId: string;
  };
  query?: never;
  url: '/api/internal/v1/deviceconfig/tenants/{tenantId}';
};

export type DeviceConfigInternalDeleteTenantErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigInternalDeleteTenantError = DeviceConfigInternalDeleteTenantErrors[keyof DeviceConfigInternalDeleteTenantErrors];

export type DeviceConfigInternalDeleteTenantResponses = {
  /**
   * All the tenant data have been successfully deleted.
   */
  204: void;
};

export type DeviceConfigInternalDeleteTenantResponse = DeviceConfigInternalDeleteTenantResponses[keyof DeviceConfigInternalDeleteTenantResponses];

export type DeviceConfigInternalProvisionDeviceData = {
  body?: ProvisionDevice;
  path: {
    /**
     * ID of tenant the device belongs to.
     */
    tenantId: string;
  };
  query?: never;
  url: '/api/internal/v1/deviceconfig/tenants/{tenantId}/devices';
};

export type DeviceConfigInternalProvisionDeviceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigInternalProvisionDeviceError = DeviceConfigInternalProvisionDeviceErrors[keyof DeviceConfigInternalProvisionDeviceErrors];

export type DeviceConfigInternalProvisionDeviceResponses = {
  /**
   * Device was provisioned successfully.
   */
  201: unknown;
};

export type DeviceConfigInternalDecommissionDeviceData = {
  body?: never;
  path: {
    /**
     * ID of tenant the device belongs to.
     */
    tenantId: string;
    /**
     * ID of the target device.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/internal/v1/deviceconfig/tenants/{tenantId}/devices/{deviceId}';
};

export type DeviceConfigInternalDecommissionDeviceErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigInternalDecommissionDeviceError = DeviceConfigInternalDecommissionDeviceErrors[keyof DeviceConfigInternalDecommissionDeviceErrors];

export type DeviceConfigInternalDecommissionDeviceResponses = {
  /**
   * Device was deleted successfully
   */
  204: void;
};

export type DeviceConfigInternalDecommissionDeviceResponse =
  DeviceConfigInternalDecommissionDeviceResponses[keyof DeviceConfigInternalDecommissionDeviceResponses];

export type DeviceConfigInternalDeployDeviceConfigurationData = {
  body?: NewConfigurationDeployment;
  path: {
    /**
     * ID of the device.
     */
    deviceId: string;
    /**
     * ID of the tenant.
     */
    tenantId: string;
  };
  query?: never;
  url: '/api/internal/v1/deviceconfig/tenants/{tenantId}/configurations/device/{deviceId}/deploy';
};

export type DeviceConfigInternalDeployDeviceConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigInternalDeployDeviceConfigurationError =
  DeviceConfigInternalDeployDeviceConfigurationErrors[keyof DeviceConfigInternalDeployDeviceConfigurationErrors];

export type DeviceConfigInternalDeployDeviceConfigurationResponses = {
  /**
   * Success
   */
  200: NewConfigurationDeploymentResponse;
};

export type DeviceConfigInternalDeployDeviceConfigurationResponse =
  DeviceConfigInternalDeployDeviceConfigurationResponses[keyof DeviceConfigInternalDeployDeviceConfigurationResponses];

export type DeviceConfigManagementGetDeviceConfigurationData = {
  body?: never;
  path: {
    /**
     * ID of the device to query.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/management/v1/deviceconfig/configurations/device/{deviceId}';
};

export type DeviceConfigManagementGetDeviceConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigManagementGetDeviceConfigurationError =
  DeviceConfigManagementGetDeviceConfigurationErrors[keyof DeviceConfigManagementGetDeviceConfigurationErrors];

export type DeviceConfigManagementGetDeviceConfigurationResponses = {
  /**
   * Success
   */
  200: DeviceConfiguration;
};

export type DeviceConfigManagementGetDeviceConfigurationResponse =
  DeviceConfigManagementGetDeviceConfigurationResponses[keyof DeviceConfigManagementGetDeviceConfigurationResponses];

export type DeviceConfigManagementSetDeviceConfigurationData = {
  body?: ManagementApiConfiguration;
  path: {
    /**
     * ID of the device to query.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/management/v1/deviceconfig/configurations/device/{deviceId}';
};

export type DeviceConfigManagementSetDeviceConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigManagementSetDeviceConfigurationError =
  DeviceConfigManagementSetDeviceConfigurationErrors[keyof DeviceConfigManagementSetDeviceConfigurationErrors];

export type DeviceConfigManagementSetDeviceConfigurationResponses = {
  /**
   * Success
   */
  204: void;
};

export type DeviceConfigManagementSetDeviceConfigurationResponse =
  DeviceConfigManagementSetDeviceConfigurationResponses[keyof DeviceConfigManagementSetDeviceConfigurationResponses];

export type DeviceConfigManagementDeployDeviceConfigurationData = {
  body: NewConfigurationDeployment;
  path: {
    /**
     * ID of the device.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/management/v1/deviceconfig/configurations/device/{deviceId}/deploy';
};

export type DeviceConfigManagementDeployDeviceConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConfigManagementDeployDeviceConfigurationError =
  DeviceConfigManagementDeployDeviceConfigurationErrors[keyof DeviceConfigManagementDeployDeviceConfigurationErrors];

export type DeviceConfigManagementDeployDeviceConfigurationResponses = {
  /**
   * Success
   */
  200: NewConfigurationDeploymentResponse;
};

export type DeviceConfigManagementDeployDeviceConfigurationResponse =
  DeviceConfigManagementDeployDeviceConfigurationResponses[keyof DeviceConfigManagementDeployDeviceConfigurationResponses];

export type DeviceConnectConnectData = {
  body?: never;
  headers?: {
    /**
     * Standard websocket request header.
     */
    Connection?: 'Upgrade';
    /**
     * Standard websocket request header.
     */
    Upgrade?: 'websocket';
    /**
     * Standard websocket request header.
     */
    'Sec-Websocket-Key'?: string;
    /**
     * Standard websocket request header.
     */
    'Sec-Websocket-Version'?: 13;
  };
  path?: never;
  query?: never;
  url: '/api/devices/v1/deviceconnect/connect';
};

export type DeviceConnectConnectErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectConnectError = DeviceConnectConnectErrors[keyof DeviceConnectConnectErrors];

export type DeviceConnectInternalCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deviceconnect/health';
};

export type DeviceConnectInternalCheckHealthErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectInternalCheckHealthError = DeviceConnectInternalCheckHealthErrors[keyof DeviceConnectInternalCheckHealthErrors];

export type DeviceConnectInternalCheckHealthResponses = {
  /**
   * Service is healthy.
   */
  204: void;
};

export type DeviceConnectInternalCheckHealthResponse = DeviceConnectInternalCheckHealthResponses[keyof DeviceConnectInternalCheckHealthResponses];

export type DeviceConnectInternalCheckLivelinessData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deviceconnect/alive';
};

export type DeviceConnectInternalCheckLivelinessErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectInternalCheckLivelinessError = DeviceConnectInternalCheckLivelinessErrors[keyof DeviceConnectInternalCheckLivelinessErrors];

export type DeviceConnectInternalCheckLivelinessResponses = {
  /**
   * Service is up and serving requests.
   */
  204: void;
};

export type DeviceConnectInternalCheckLivelinessResponse = DeviceConnectInternalCheckLivelinessResponses[keyof DeviceConnectInternalCheckLivelinessResponses];

export type DeviceConnectInternalShutdownData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/deviceconnect/shutdown';
};

export type DeviceConnectInternalShutdownErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectInternalShutdownError = DeviceConnectInternalShutdownErrors[keyof DeviceConnectInternalShutdownErrors];

export type DeviceConnectInternalShutdownResponses = {
  /**
   * The service started the graceful shutdown procedure.
   */
  202: unknown;
};

export type DeleteTenantDataData = {
  body?: never;
  path: {
    /**
     * ID of tenant.
     */
    tenantId: string;
  };
  query?: never;
  url: '/api/internal/v1/deviceconnect/tenants/{tenantId}';
};

export type DeleteTenantDataErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteTenantDataError = DeleteTenantDataErrors[keyof DeleteTenantDataErrors];

export type DeleteTenantDataResponses = {
  /**
   * All the tenant data have been successfully deleted.
   */
  204: void;
};

export type DeleteTenantDataResponse = DeleteTenantDataResponses[keyof DeleteTenantDataResponses];

export type DeviceConnectInternalProvisionDeviceData = {
  body?: ProvisionDevice;
  path: {
    /**
     * ID of tenant the device belongs to.
     */
    tenantId: string;
  };
  query?: never;
  url: '/api/internal/v1/deviceconnect/tenants/{tenantId}/devices';
};

export type DeviceConnectInternalProvisionDeviceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectInternalProvisionDeviceError = DeviceConnectInternalProvisionDeviceErrors[keyof DeviceConnectInternalProvisionDeviceErrors];

export type DeviceConnectInternalProvisionDeviceResponses = {
  /**
   * Device was provisioned successfully.
   */
  201: unknown;
};

export type DeviceConnectInternalDecomissionDeviceData = {
  body?: never;
  path: {
    /**
     * ID of tenant the device belongs to.
     */
    tenantId: string;
    /**
     * ID of the target device.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/internal/v1/deviceconnect/tenants/{tenantId}/devices/{deviceId}';
};

export type DeviceConnectInternalDecomissionDeviceErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectInternalDecomissionDeviceError = DeviceConnectInternalDecomissionDeviceErrors[keyof DeviceConnectInternalDecomissionDeviceErrors];

export type DeviceConnectInternalDecomissionDeviceResponses = {
  /**
   * Device was deleted successfully
   */
  202: unknown;
};

export type DeviceConnectInternalCheckUpdateData = {
  body?: never;
  path: {
    /**
     * ID of tenant the device belongs to.
     */
    tenantId: string;
    /**
     * ID for the target device.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/internal/v1/deviceconnect/tenants/{tenantId}/devices/{deviceId}/check-update';
};

export type DeviceConnectInternalCheckUpdateErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectInternalCheckUpdateError = DeviceConnectInternalCheckUpdateErrors[keyof DeviceConnectInternalCheckUpdateErrors];

export type DeviceConnectInternalCheckUpdateResponses = {
  /**
   * Accepted
   */
  202: unknown;
};

export type DeviceConnectInternalSendInventoryData = {
  body?: never;
  path: {
    /**
     * ID of tenant the device belongs to.
     */
    tenantId: string;
    /**
     * ID for the target device.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/internal/v1/deviceconnect/tenants/{tenantId}/devices/{deviceId}/send-inventory';
};

export type DeviceConnectInternalSendInventoryErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectInternalSendInventoryError = DeviceConnectInternalSendInventoryErrors[keyof DeviceConnectInternalSendInventoryErrors];

export type DeviceConnectInternalSendInventoryResponses = {
  /**
   * Accepted
   */
  202: unknown;
};

export type DeviceConnectManagementGetDeviceData = {
  body?: never;
  path: {
    /**
     * ID of the device.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deviceconnect/devices/{id}';
};

export type DeviceConnectManagementGetDeviceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectManagementGetDeviceError = DeviceConnectManagementGetDeviceErrors[keyof DeviceConnectManagementGetDeviceErrors];

export type DeviceConnectManagementGetDeviceResponses = {
  /**
   * Successful response.
   */
  200: ConnectionState;
};

export type DeviceConnectManagementGetDeviceResponse = DeviceConnectManagementGetDeviceResponses[keyof DeviceConnectManagementGetDeviceResponses];

export type DeviceConnectManagementCheckUpdateData = {
  body?: never;
  path: {
    /**
     * ID of the device.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deviceconnect/devices/{id}/check-update';
};

export type DeviceConnectManagementCheckUpdateErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectManagementCheckUpdateError = DeviceConnectManagementCheckUpdateErrors[keyof DeviceConnectManagementCheckUpdateErrors];

export type DeviceConnectManagementCheckUpdateResponses = {
  /**
   * Accepted
   */
  202: unknown;
};

export type DeviceConnectManagementConnectData = {
  body?: never;
  headers?: {
    /**
     * Standard websocket request header.
     */
    Connection?: 'Upgrade';
    /**
     * Standard websocket request header.
     */
    Upgrade?: 'websocket';
    /**
     * Standard websocket request header.
     */
    'Sec-Websocket-Key'?: string;
    /**
     * Standard websocket request header.
     */
    'Sec-Websocket-Version'?: 13;
  };
  path: {
    /**
     * ID of the device.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deviceconnect/devices/{id}/connect';
};

export type DeviceConnectManagementConnectErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectManagementConnectError = DeviceConnectManagementConnectErrors[keyof DeviceConnectManagementConnectErrors];

export type DeviceConnectManagementDownloadData = {
  body?: never;
  path: {
    /**
     * ID of the device.
     */
    id: string;
  };
  query: {
    /**
     * Path of the file on the device.
     */
    path: string;
  };
  url: '/api/management/v1/deviceconnect/devices/{id}/download';
};

export type DeviceConnectManagementDownloadErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectManagementDownloadError = DeviceConnectManagementDownloadErrors[keyof DeviceConnectManagementDownloadErrors];

export type DeviceConnectManagementDownloadResponses = {
  /**
   * The content of the file will be returned in the response body
   */
  200: Blob | File;
};

export type DeviceConnectManagementDownloadResponse = DeviceConnectManagementDownloadResponses[keyof DeviceConnectManagementDownloadResponses];

export type DeviceConnectManagementSendInventoryData = {
  body?: never;
  path: {
    /**
     * ID of the device.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deviceconnect/devices/{id}/send-inventory';
};

export type DeviceConnectManagementSendInventoryErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectManagementSendInventoryError = DeviceConnectManagementSendInventoryErrors[keyof DeviceConnectManagementSendInventoryErrors];

export type DeviceConnectManagementSendInventoryResponses = {
  /**
   * Accepted
   */
  202: unknown;
};

export type DeviceConnectManagementPlaybackData = {
  body?: never;
  headers?: {
    /**
     * Standard websocket request header.
     */
    Connection?: 'Upgrade';
    /**
     * Standard websocket request header.
     */
    Upgrade?: 'websocket';
    /**
     * Standard websocket request header.
     */
    'Sec-Websocket-Key'?: string;
    /**
     * Standard websocket request header.
     */
    'Sec-Websocket-Version'?: 13;
  };
  path: {
    /**
     * ID for the session to play back.
     */
    session_id: string;
  };
  query?: {
    /**
     * Time in millisconds to sleep between the subsequent playback data writes.
     */
    sleep_ms?: number;
  };
  url: '/api/management/v1/deviceconnect/sessions/{session_id}/playback';
};

export type DeviceConnectManagementPlaybackErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectManagementPlaybackError = DeviceConnectManagementPlaybackErrors[keyof DeviceConnectManagementPlaybackErrors];

export type DeviceConnectManagementUploadData = {
  body?: FileUpload;
  path: {
    /**
     * ID of the device.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/deviceconnect/devices/{id}/upload';
};

export type DeviceConnectManagementUploadErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceConnectManagementUploadError = DeviceConnectManagementUploadErrors[keyof DeviceConnectManagementUploadErrors];

export type DeviceConnectManagementUploadResponses = {
  /**
   * The file was successfully uploaded
   */
  201: unknown;
};

export type DeviceAlertPostData = {
  body: Array<Alert>;
  path?: never;
  query?: never;
  url: '/api/devices/v1/devicemonitor/alert';
};

export type DeviceAlertPostErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceAlertPostError = DeviceAlertPostErrors[keyof DeviceAlertPostErrors];

export type DeviceAlertPostResponses = {
  /**
   * The service processed the alert.
   *
   */
  204: void;
};

export type DeviceAlertPostResponse = DeviceAlertPostResponses[keyof DeviceAlertPostResponses];

export type SetMonitorConfigurationData = {
  body: Array<DeviceMonitorConfiguration>;
  path?: never;
  query?: never;
  url: '/api/devices/v1/devicemonitor/config';
};

export type SetMonitorConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type SetMonitorConfigurationError = SetMonitorConfigurationErrors[keyof SetMonitorConfigurationErrors];

export type SetMonitorConfigurationResponses = {
  /**
   * The service saved given configuration data.
   *
   */
  204: void;
};

export type SetMonitorConfigurationResponse = SetMonitorConfigurationResponses[keyof SetMonitorConfigurationResponses];

export type DeviceMonitorInternalDeleteTenantData = {
  body?: never;
  path: {
    /**
     * ID of tenant.
     */
    tenantId: string;
  };
  query?: never;
  url: '/api/internal/v1/devicemonitor/tenants/{tenantId}';
};

export type DeviceMonitorInternalDeleteTenantErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceMonitorInternalDeleteTenantError = DeviceMonitorInternalDeleteTenantErrors[keyof DeviceMonitorInternalDeleteTenantErrors];

export type DeviceMonitorInternalDeleteTenantResponses = {
  /**
   * All the tenant data have been successfully deleted.
   */
  204: void;
};

export type DeviceMonitorInternalDeleteTenantResponse = DeviceMonitorInternalDeleteTenantResponses[keyof DeviceMonitorInternalDeleteTenantResponses];

export type ListDevicesAndTheirLatestAlertsData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: {
    /**
     * Device ID filter. Can be repeated to query a set of devices.
     */
    id?: Array<string>;
    /**
     * Results page number
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/internal/v1/devicemonitor/tenants/{tenant_id}/devices';
};

export type ListDevicesAndTheirLatestAlertsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListDevicesAndTheirLatestAlertsError = ListDevicesAndTheirLatestAlertsErrors[keyof ListDevicesAndTheirLatestAlertsErrors];

export type ListDevicesAndTheirLatestAlertsResponses = {
  /**
   * OK
   */
  200: Array<MonitorDevice>;
};

export type ListDevicesAndTheirLatestAlertsResponse = ListDevicesAndTheirLatestAlertsResponses[keyof ListDevicesAndTheirLatestAlertsResponses];

export type DeleteTenantDeviceData = {
  body?: never;
  path: {
    /**
     * ID of tenant.
     */
    tenant_id: string;
    /**
     * ID of device.
     */
    device_id: string;
  };
  query?: never;
  url: '/api/internal/v1/devicemonitor/tenants/{tenant_id}/devices/{device_id}';
};

export type DeleteTenantDeviceErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteTenantDeviceError = DeleteTenantDeviceErrors[keyof DeleteTenantDeviceErrors];

export type DeleteTenantDeviceResponses = {
  /**
   * All the device data has been successfully deleted.
   */
  204: void;
};

export type DeleteTenantDeviceResponse = DeleteTenantDeviceResponses[keyof DeleteTenantDeviceResponses];

export type DeviceMonitorInternalListLatestAlertsData = {
  body?: never;
  path: {
    /**
     * Device ID.
     */
    device_id: string;
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: {
    /**
     * Filter the result by having `level_from` or higher severity level.
     */
    level_from?: 'OK' | 'CRITICAL';
  };
  url: '/api/internal/v1/devicemonitor/tenants/{tenant_id}/devices/{device_id}/alerts/latest';
};

export type DeviceMonitorInternalListLatestAlertsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeviceMonitorInternalListLatestAlertsError = DeviceMonitorInternalListLatestAlertsErrors[keyof DeviceMonitorInternalListLatestAlertsErrors];

export type DeviceMonitorInternalListLatestAlertsResponses = {
  /**
   * OK
   */
  200: Array<Alert>;
};

export type DeviceMonitorInternalListLatestAlertsResponse =
  DeviceMonitorInternalListLatestAlertsResponses[keyof DeviceMonitorInternalListLatestAlertsResponses];

export type ListAlertsData = {
  body?: never;
  path: {
    /**
     * Device ID.
     */
    id: string;
  };
  query?: {
    /**
     * The requested page number.
     */
    page?: number;
    /**
     * The number of items per page.
     */
    per_page?: number;
    /**
     * Filter alerts issued before timestamp.
     */
    issued_before?: string;
    /**
     * Filter alerts issued after timestamp.
     */
    issued_after?: string;
    /**
     * Filter by ascending timestamp (reverse).
     */
    sort_ascending?: 'true' | 'false';
  };
  url: '/api/management/v1/devicemonitor/devices/{id}/alerts';
};

export type ListAlertsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListAlertsError = ListAlertsErrors[keyof ListAlertsErrors];

export type ListAlertsResponses = {
  /**
   * OK
   */
  200: Array<Alert>;
};

export type ListAlertsResponse = ListAlertsResponses[keyof ListAlertsResponses];

export type ListLatestAlertsData = {
  body?: never;
  path: {
    /**
     * Device ID.
     */
    id: string;
  };
  query?: {
    /**
     * Filter the result by having `level_from` or higher severity level.
     */
    level_from?: 'OK' | 'CRITICAL';
    /**
     * Only show alerts older than `issued_before`.
     */
    issued_before?: string;
    /**
     * Only show alerts older than `issued_after`.
     */
    issued_after?: string;
    /**
     * The requested page number.
     */
    page?: number;
    /**
     * The number of items per page.
     */
    per_page?: number;
  };
  url: '/api/management/v1/devicemonitor/devices/{id}/alerts/latest';
};

export type ListLatestAlertsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListLatestAlertsError = ListLatestAlertsErrors[keyof ListLatestAlertsErrors];

export type ListLatestAlertsResponses = {
  /**
   * OK.
   * Lists latest alerts sorted by oldest alert first.
   *
   */
  200: Array<Alert>;
};

export type ListLatestAlertsResponse = ListLatestAlertsResponses[keyof ListLatestAlertsResponses];

export type MonitorChecksConfigurationData = {
  body?: never;
  path: {
    /**
     * Device ID.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/devicemonitor/devices/{id}/config';
};

export type MonitorChecksConfigurationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type MonitorChecksConfigurationError = MonitorChecksConfigurationErrors[keyof MonitorChecksConfigurationErrors];

export type MonitorChecksConfigurationResponses = {
  /**
   * OK
   */
  200: Array<MonitorConfiguration>;
};

export type MonitorChecksConfigurationResponse = MonitorChecksConfigurationResponses[keyof MonitorChecksConfigurationResponses];

export type ToggleChannelMuteData = {
  body?: {
    /**
     * Enable/disable channel
     */
    enabled?: boolean;
  };
  path: {
    /**
     * Channel name
     */
    name: 'email';
  };
  query?: never;
  url: '/api/management/v1/devicemonitor/settings/global/channel/alerts/{name}/status';
};

export type ToggleChannelMuteErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ToggleChannelMuteError = ToggleChannelMuteErrors[keyof ToggleChannelMuteErrors];

export type ToggleChannelMuteResponses = {
  /**
   * Update successful (no content)
   */
  204: void;
};

export type ToggleChannelMuteResponse = ToggleChannelMuteResponses[keyof ToggleChannelMuteResponses];

export type AssignAttributesData = {
  /**
   * ListOfAttributes
   *
   * A list of attribute descriptors.
   */
  body: Array<Attribute>;
  path?: never;
  query?: never;
  url: '/api/devices/v1/inventory/device/attributes';
};

export type AssignAttributesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AssignAttributesError = AssignAttributesErrors[keyof AssignAttributesErrors];

export type AssignAttributesResponses = {
  /**
   * Attributes were uploaded successfully.
   */
  200: unknown;
};

export type ReplaceAttributesData = {
  /**
   * ListOfAttributes
   *
   * A list of attribute descriptors.
   */
  body: Array<Attribute>;
  path?: never;
  query?: never;
  url: '/api/devices/v1/inventory/device/attributes';
};

export type ReplaceAttributesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ReplaceAttributesError = ReplaceAttributesErrors[keyof ReplaceAttributesErrors];

export type ReplaceAttributesResponses = {
  /**
   * Attributes were uploaded successfully.
   */
  200: unknown;
};

export type InventoryInternalCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/inventory/health';
};

export type InventoryInternalCheckHealthErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
  /**
   * Service unhealthy / not ready to accept traffic. At least one dependency is not running.
   *
   */
  503: unknown;
};

export type InventoryInternalCheckHealthError = InventoryInternalCheckHealthErrors[keyof InventoryInternalCheckHealthErrors];

export type InventoryInternalCheckHealthResponses = {
  /**
   * Service is healthy and all dependencies are up and running.
   *
   */
  204: void;
};

export type InventoryInternalCheckHealthResponse = InventoryInternalCheckHealthResponses[keyof InventoryInternalCheckHealthResponses];

export type InventoryInternalCheckLivelinessData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/inventory/alive';
};

export type InventoryInternalCheckLivelinessErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InventoryInternalCheckLivelinessError = InventoryInternalCheckLivelinessErrors[keyof InventoryInternalCheckLivelinessErrors];

export type InventoryInternalCheckLivelinessResponses = {
  /**
   * Service is up and running.
   */
  204: void;
};

export type InventoryInternalCheckLivelinessResponse = InventoryInternalCheckLivelinessResponses[keyof InventoryInternalCheckLivelinessResponses];

export type InventoryInternalCreateTenantData = {
  body: TenantNew;
  path?: never;
  query?: never;
  url: '/api/internal/v1/inventory/tenants';
};

export type InventoryInternalCreateTenantErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InventoryInternalCreateTenantError = InventoryInternalCreateTenantErrors[keyof InventoryInternalCreateTenantErrors];

export type InventoryInternalCreateTenantResponses = {
  /**
   * The tenant was created successfully.
   */
  201: unknown;
};

export type InitializeDeviceData = {
  body: DeviceNew;
  path: {
    /**
     * ID of given tenant.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/inventory/tenants/{tenant_id}/devices';
};

export type InitializeDeviceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InitializeDeviceError = InitializeDeviceErrors[keyof InitializeDeviceErrors];

export type InitializeDeviceResponses = {
  /**
   * The device was successfully created.
   */
  201: unknown;
};

export type DeleteTenantSpecificDataData = {
  body?: never;
  path: {
    /**
     * ID of given tenant.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/inventory/tenants/{tenant_id}';
};

export type DeleteTenantSpecificDataErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteTenantSpecificDataError = DeleteTenantSpecificDataErrors[keyof DeleteTenantSpecificDataErrors];

export type DeleteTenantSpecificDataResponses = {
  /**
   * Tenant data was removed successfuly.
   */
  204: void;
};

export type DeleteTenantSpecificDataResponse = DeleteTenantSpecificDataResponses[keyof DeleteTenantSpecificDataResponses];

export type DeleteDeviceData = {
  body?: never;
  path: {
    /**
     * ID of given tenant.
     */
    tenant_id: string;
    /**
     * ID of given device.
     */
    device_id: string;
  };
  query?: never;
  url: '/api/internal/v1/inventory/tenants/{tenant_id}/devices/{device_id}';
};

export type DeleteDeviceErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteDeviceError = DeleteDeviceErrors[keyof DeleteDeviceErrors];

export type DeleteDeviceResponses = {
  /**
   * Device removed
   */
  204: void;
};

export type DeleteDeviceResponse = DeleteDeviceResponses[keyof DeleteDeviceResponses];

export type UpdateStatusOfDevicesData = {
  /**
   * A list of devices to update.
   */
  body: Array<DeviceUpdate>;
  path: {
    /**
     * ID of given tenant.
     */
    tenant_id: string;
    /**
     * New status to set for the specified devices.
     */
    status: string;
  };
  query?: never;
  url: '/api/internal/v1/inventory/tenants/{tenant_id}/devices/status/{status}';
};

export type UpdateStatusOfDevicesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateStatusOfDevicesError = UpdateStatusOfDevicesErrors[keyof UpdateStatusOfDevicesErrors];

export type UpdateStatusOfDevicesResponses = {
  /**
   * The operation completed successfully.
   */
  200: unknown;
};

export type UpdateInventoryForADeviceData = {
  /**
   * A list of attribute descriptors.
   */
  body: Array<Attribute>;
  headers?: {
    /**
     * Skips updating the device if modified after the given RFC1123 timestamp.
     */
    'If-Unmodified-Since'?: string;
  };
  path: {
    /**
     * ID of given tenant.
     */
    tenant_id: string;
    /**
     * ID of given device.
     */
    device_id: string;
    /**
     * Scope of the inventory attributes.
     */
    scope: string;
  };
  query?: never;
  url: '/api/internal/v1/inventory/tenants/{tenant_id}/device/{device_id}/attribute/scope/{scope}';
};

export type UpdateInventoryForADeviceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Precondition failed: If-Unmodified-Since condition not met
   */
  412: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateInventoryForADeviceError = UpdateInventoryForADeviceErrors[keyof UpdateInventoryForADeviceErrors];

export type UpdateInventoryForADeviceResponses = {
  /**
   * Device inventory successfully updated.
   */
  200: unknown;
};

export type GetDeviceGroupsData = {
  body?: never;
  path: {
    /**
     * ID of given tenant.
     */
    tenant_id: string;
    /**
     * Device identifier.
     */
    device_id: string;
  };
  query?: never;
  url: '/api/internal/v1/inventory/tenants/{tenant_id}/devices/{device_id}/groups';
};

export type GetDeviceGroupsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetDeviceGroupsError = GetDeviceGroupsErrors[keyof GetDeviceGroupsErrors];

export type GetDeviceGroupsResponses = {
  /**
   * Successful response.
   *
   */
  200: Groups;
};

export type GetDeviceGroupsResponse = GetDeviceGroupsResponses[keyof GetDeviceGroupsResponses];

export type CheckIfDevicesBelongsToGivenGroupsData = {
  body: DevicesInGroupsReq;
  path: {
    /**
     * ID of given tenant.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/inventory/tenants/{tenant_id}/test/devices/groups';
};

export type CheckIfDevicesBelongsToGivenGroupsErrors = {
  /**
   * Not all the devices belong to given groups.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CheckIfDevicesBelongsToGivenGroupsError = CheckIfDevicesBelongsToGivenGroupsErrors[keyof CheckIfDevicesBelongsToGivenGroupsErrors];

export type CheckIfDevicesBelongsToGivenGroupsResponses = {
  /**
   * All the devices belong to given groups.
   */
  200: unknown;
};

export type StartReIndexingData = {
  body?: never;
  path: {
    /**
     * ID of the device that needs reindexing.
     */
    device_id: string;
    /**
     * ID of tenant owning the device.
     */
    tenant_id: string;
  };
  query?: {
    /**
     * The name of the calling service.
     */
    service?: string;
  };
  url: '/api/internal/v1/inventory/tenants/{tenant_id}/devices/{device_id}/reindex';
};

export type StartReIndexingErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type StartReIndexingError = StartReIndexingErrors[keyof StartReIndexingErrors];

export type StartReIndexingResponses = {
  /**
   * Attributes have been re-indexed.
   */
  200: unknown;
};

export type InventoryInternalV2SearchDeviceInventoriesData = {
  /**
   * The search and sort parameters of the filter
   */
  body?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Number of results per page.
     */
    per_page?: number;
    /**
     * List of device IDs
     */
    device_ids?: Array<string>;
    /**
     * Free-text search query
     */
    text?: string;
    /**
     * List of filter predicates, chained with boolean AND operators to build the search condition definition.
     */
    filters?: Array<FilterPredicate>;
    /**
     * List of ordered sort criterias
     */
    sort?: Array<SortCriteria>;
    /**
     * List of attributes to select and return
     */
    attributes?: Array<SelectAttribute>;
  };
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v2/inventory/tenants/{tenant_id}/filters/search';
};

export type InventoryInternalV2SearchDeviceInventoriesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InventoryInternalV2SearchDeviceInventoriesError =
  InventoryInternalV2SearchDeviceInventoriesErrors[keyof InventoryInternalV2SearchDeviceInventoriesErrors];

export type InventoryInternalV2SearchDeviceInventoriesResponses = {
  /**
   * ListOfDevices
   *
   * Successful response.
   */
  200: Array<DeviceInventory>;
};

export type InventoryInternalV2SearchDeviceInventoriesResponse =
  InventoryInternalV2SearchDeviceInventoriesResponses[keyof InventoryInternalV2SearchDeviceInventoriesResponses];

export type InternalV2ShowFilterData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
    /**
     * Filter identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v2/tenants/{tenant_id}/filters/{id}';
};

export type InternalV2ShowFilterErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * The filter was not found.
   */
  404: ErrorNotFound;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InternalV2ShowFilterError = InternalV2ShowFilterErrors[keyof InternalV2ShowFilterErrors];

export type InternalV2ShowFilterResponses = {
  /**
   * Successful response.
   */
  200: Filter;
};

export type InternalV2ShowFilterResponse = InternalV2ShowFilterResponses[keyof InternalV2ShowFilterResponses];

export type ListDeviceInventoriesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
    /**
     * Sort devices by attribute.
     * The parameter is formatted as a comma-separated list of attribute
     * names and sort order.
     *
     * The order direction (`ord`) must be either `asc` or `desc` for
     * ascending and descending respectively.
     * Defaults to `desc` if not specified.
     *
     * For example: `?sort=attr1:asc,attr2:desc`
     * will sort by 'attr1' ascending, and then by 'attr2' descending.
     *
     */
    sort?: string;
    /**
     * Limit result to devices assigned to a group.
     */
    has_group?: boolean;
    /**
     * Limits result to devices in the given group.
     */
    group?: string;
  };
  url: '/api/management/v1/inventory/devices';
};

export type ListDeviceInventoriesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListDeviceInventoriesError = ListDeviceInventoriesErrors[keyof ListDeviceInventoriesErrors];

export type ListDeviceInventoriesResponses = {
  /**
   * ListOfDevices
   *
   * Successful response.
   */
  200: Array<DeviceInventoryV1>;
};

export type ListDeviceInventoriesResponse = ListDeviceInventoriesResponses[keyof ListDeviceInventoriesResponses];

export type DeleteDeviceInventoryData = {
  body?: never;
  path: {
    /**
     * Device identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/devices/{id}';
};

export type DeleteDeviceInventoryErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteDeviceInventoryError = DeleteDeviceInventoryErrors[keyof DeleteDeviceInventoryErrors];

export type DeleteDeviceInventoryResponses = {
  /**
   * Device removed
   */
  204: void;
};

export type DeleteDeviceInventoryResponse = DeleteDeviceInventoryResponses[keyof DeleteDeviceInventoryResponses];

export type GetDeviceInventoryData = {
  body?: never;
  path: {
    /**
     * Device identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/devices/{id}';
};

export type GetDeviceInventoryErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetDeviceInventoryError = GetDeviceInventoryErrors[keyof GetDeviceInventoryErrors];

export type GetDeviceInventoryResponses = {
  /**
   * Successful response - the device was found.
   */
  200: DeviceInventoryV1;
};

export type GetDeviceInventoryResponse = GetDeviceInventoryResponses[keyof GetDeviceInventoryResponses];

export type AddTagsData = {
  /**
   * ListOfTags
   *
   * A list of tag descriptors.
   */
  body: Array<Tag>;
  headers?: {
    /**
     * Contains the device object's current ETag, and performs the update only if it matches the one stored in the database.
     */
    'If-Match'?: string;
  };
  path: {
    /**
     * Device identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/devices/{id}/tags';
};

export type AddTagsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * ETag doesn't match.
   */
  412: unknown;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AddTagsError = AddTagsErrors[keyof AddTagsErrors];

export type AddTagsResponses = {
  /**
   * Tags were updated successfully.
   */
  200: unknown;
};

export type AssignTagsData = {
  /**
   * ListOfTags
   *
   * A list of tags descriptors.
   */
  body: Array<Tag>;
  headers?: {
    /**
     * Contains the device object's current ETag, and performs the update only if it matches the one stored in the database.
     */
    'If-Match'?: string;
  };
  path: {
    /**
     * Device identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/devices/{id}/tags';
};

export type AssignTagsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * ETag doesn't match.
   */
  412: unknown;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AssignTagsError = AssignTagsErrors[keyof AssignTagsErrors];

export type AssignTagsResponses = {
  /**
   * Tags were updated successfully.
   */
  200: unknown;
};

export type GetDeviceGroupData = {
  body?: never;
  path: {
    /**
     * Device identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/devices/{id}/group';
};

export type GetDeviceGroupErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetDeviceGroupError = GetDeviceGroupErrors[keyof GetDeviceGroupErrors];

export type GetDeviceGroupResponses = {
  /**
   * Successful response. If the device is not assigned to any group, the 'group' field will be set to 'null'.
   *
   */
  200: Group;
};

export type GetDeviceGroupResponse = GetDeviceGroupResponses[keyof GetDeviceGroupResponses];

export type AssignGroupData = {
  /**
   * Group descriptor.
   */
  body: Group;
  path: {
    /**
     * Device identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/devices/{id}/group';
};

export type AssignGroupErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AssignGroupError = AssignGroupErrors[keyof AssignGroupErrors];

export type AssignGroupResponses = {
  /**
   * Success - the device was added to the group.
   */
  204: void;
};

export type AssignGroupResponse = AssignGroupResponses[keyof AssignGroupResponses];

export type ClearGroupData = {
  body?: never;
  path: {
    /**
     * Device identifier.
     */
    id: string;
    /**
     * Group name.
     */
    name: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/devices/{id}/group/{name}';
};

export type ClearGroupErrors = {
  /**
   * The device was not found or doesn't belong to the group.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ClearGroupError = ClearGroupErrors[keyof ClearGroupErrors];

export type ClearGroupResponses = {
  /**
   * The device was successfully removed from the group.
   */
  204: void;
};

export type ClearGroupResponse = ClearGroupResponses[keyof ClearGroupResponses];

export type ListGroupsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Show groups for devices with the given auth set status.
     */
    status?: string;
  };
  url: '/api/management/v1/inventory/groups';
};

export type ListGroupsErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListGroupsError = ListGroupsErrors[keyof ListGroupsErrors];

export type ListGroupsResponses = {
  /**
   * Successful response.
   */
  200: Array<string>;
};

export type ListGroupsResponse = ListGroupsResponses[keyof ListGroupsResponses];

export type RemoveAGroupData = {
  body?: never;
  path: {
    /**
     * Group name.
     */
    name: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/groups/{name}';
};

export type RemoveAGroupErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type RemoveAGroupError = RemoveAGroupErrors[keyof RemoveAGroupErrors];

export type RemoveAGroupResponses = {
  /**
   * JSON object listing how many devices were updated.
   *
   */
  200: {
    /**
     * Number of devices for which the group was cleared sucessfully.
     *
     */
    updated_count: number;
  };
};

export type RemoveAGroupResponse = RemoveAGroupResponses[keyof RemoveAGroupResponses];

export type RemoveDevicesFromGroupData = {
  /**
   * JSON list of device IDs to remove from the group.
   */
  body: Array<string>;
  path: {
    /**
     * Group name.
     */
    name: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/groups/{name}/devices';
};

export type RemoveDevicesFromGroupErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type RemoveDevicesFromGroupError = RemoveDevicesFromGroupErrors[keyof RemoveDevicesFromGroupErrors];

export type RemoveDevicesFromGroupResponses = {
  /**
   * JSON object listing how many devices were updated.
   *
   */
  200: {
    /**
     * Number of devices for which the group was cleared sucessfully.
     *
     */
    updated_count: number;
  };
};

export type RemoveDevicesFromGroupResponse = RemoveDevicesFromGroupResponses[keyof RemoveDevicesFromGroupResponses];

export type GetDevicesInGroupData = {
  body?: never;
  path: {
    /**
     * Group name.
     */
    name: string;
  };
  query?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v1/inventory/groups/{name}/devices';
};

export type GetDevicesInGroupErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetDevicesInGroupError = GetDevicesInGroupErrors[keyof GetDevicesInGroupErrors];

export type GetDevicesInGroupResponses = {
  /**
   * ListOfIDs
   *
   * Successful response
   */
  200: Array<string>;
};

export type GetDevicesInGroupResponse = GetDevicesInGroupResponses[keyof GetDevicesInGroupResponses];

export type AddDevicesToGroupData = {
  /**
   * JSON list of device IDs to append to the group.
   */
  body: Array<string>;
  path: {
    /**
     * Group name.
     */
    name: string;
  };
  query?: never;
  url: '/api/management/v1/inventory/groups/{name}/devices';
};

export type AddDevicesToGroupErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AddDevicesToGroupError = AddDevicesToGroupErrors[keyof AddDevicesToGroupErrors];

export type AddDevicesToGroupResponses = {
  /**
   * JSON object listing how many devices were updated.
   *
   */
  200: {
    /**
     * Number of devices listed that changed group.
     *
     */
    updated_count: number;
    /**
     * Number of devices listed that matched a valid device id internally.
     *
     */
    matched_count: number;
  };
};

export type AddDevicesToGroupResponse = AddDevicesToGroupResponses[keyof AddDevicesToGroupResponses];

export type GetFilterableAttributesData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v2/inventory/filters/attributes';
};

export type GetFilterableAttributesErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetFilterableAttributesError = GetFilterableAttributesErrors[keyof GetFilterableAttributesErrors];

export type GetFilterableAttributesResponses = {
  /**
   * List of filter attributes
   *
   * Successful response.
   */
  200: Array<FilterAttribute>;
};

export type GetFilterableAttributesResponse = GetFilterableAttributesResponses[keyof GetFilterableAttributesResponses];

export type InventoryV2SearchDeviceInventoriesData = {
  /**
   * The search and sort parameters of the filter
   */
  body?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
    /**
     * Free-text search query
     */
    text?: string;
    /**
     * List of filter predicates.
     */
    filters?: Array<FilterPredicate>;
    /**
     * List of ordered sort criteria
     */
    sort?: Array<SortCriteria>;
    /**
     * List of attributes to select and return
     */
    attributes?: Array<SelectAttribute>;
  };
  path?: never;
  query?: never;
  url: '/api/management/v2/inventory/filters/search';
};

export type InventoryV2SearchDeviceInventoriesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InventoryV2SearchDeviceInventoriesError = InventoryV2SearchDeviceInventoriesErrors[keyof InventoryV2SearchDeviceInventoriesErrors];

export type InventoryV2SearchDeviceInventoriesResponses = {
  /**
   * ListOfDevices
   *
   * Successful response.
   */
  200: Array<DeviceInventory>;
};

export type InventoryV2SearchDeviceInventoriesResponse = InventoryV2SearchDeviceInventoriesResponses[keyof InventoryV2SearchDeviceInventoriesResponses];

export type ListFiltersData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v2/inventory/filters';
};

export type ListFiltersErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListFiltersError = ListFiltersErrors[keyof ListFiltersErrors];

export type ListFiltersResponses = {
  /**
   * ListOfFilters
   *
   * Successful response.
   */
  200: Array<Filter>;
};

export type ListFiltersResponse = ListFiltersResponses[keyof ListFiltersResponses];

export type CreateFilterData = {
  /**
   * The definition of the filter
   */
  body?: FilterDefinition;
  path?: never;
  query?: never;
  url: '/api/management/v2/inventory/filters';
};

export type CreateFilterErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * A filter with the same name already exists.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreateFilterError = CreateFilterErrors[keyof CreateFilterErrors];

export type CreateFilterResponses = {
  /**
   * The filter was successfully created.
   */
  201: unknown;
};

export type DeleteFilterData = {
  body?: never;
  path: {
    /**
     * Filter identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/inventory/filters/{id}';
};

export type DeleteFilterErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteFilterError = DeleteFilterErrors[keyof DeleteFilterErrors];

export type DeleteFilterResponses = {
  /**
   * The filter was successfully deleted.
   */
  204: void;
};

export type DeleteFilterResponse = DeleteFilterResponses[keyof DeleteFilterResponses];

export type ShowFilterData = {
  body?: never;
  path: {
    /**
     * Filter identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/inventory/filters/{id}';
};

export type ShowFilterErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowFilterError = ShowFilterErrors[keyof ShowFilterErrors];

export type ShowFilterResponses = {
  /**
   * Successful response.
   */
  200: Filter;
};

export type ShowFilterResponse = ShowFilterResponses[keyof ShowFilterResponses];

export type UpdateFilterData = {
  /**
   * The definition of the filter
   */
  body?: FilterDefinition;
  path: {
    /**
     * Filter identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/inventory/filters/{id}';
};

export type UpdateFilterErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateFilterError = UpdateFilterErrors[keyof UpdateFilterErrors];

export type UpdateFilterResponses = {
  /**
   * The filter was successfully updated.
   */
  204: void;
};

export type UpdateFilterResponse = UpdateFilterResponses[keyof UpdateFilterResponses];

export type ExecuteFilterData = {
  body?: never;
  path: {
    /**
     * Filter identifier.
     */
    id: string;
  };
  query?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v2/inventory/filters/{id}/search';
};

export type ExecuteFilterErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ExecuteFilterError = ExecuteFilterErrors[keyof ExecuteFilterErrors];

export type ExecuteFilterResponses = {
  /**
   * ListOfDevices
   *
   * Successful response.
   */
  200: Array<DeviceInventory>;
};

export type ExecuteFilterResponse = ExecuteFilterResponses[keyof ExecuteFilterResponses];

export type IoTManagerInternalCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/iot-manager/health';
};

export type IoTManagerInternalCheckHealthErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerInternalCheckHealthError = IoTManagerInternalCheckHealthErrors[keyof IoTManagerInternalCheckHealthErrors];

export type IoTManagerInternalCheckHealthResponses = {
  /**
   * Service is healthy.
   */
  204: void;
};

export type IoTManagerInternalCheckHealthResponse = IoTManagerInternalCheckHealthResponses[keyof IoTManagerInternalCheckHealthResponses];

export type IoTManagerInternalCheckLivelinessData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/iot-manager/alive';
};

export type IoTManagerInternalCheckLivelinessErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerInternalCheckLivelinessError = IoTManagerInternalCheckLivelinessErrors[keyof IoTManagerInternalCheckLivelinessErrors];

export type IoTManagerInternalCheckLivelinessResponses = {
  /**
   * Service is up and serving requests.
   */
  204: void;
};

export type IoTManagerInternalCheckLivelinessResponse = IoTManagerInternalCheckLivelinessResponses[keyof IoTManagerInternalCheckLivelinessResponses];

export type IoTManagerInternalProvisionDeviceData = {
  body: NewDevice;
  path: {
    /**
     * ID of tenant the device belongs to.
     */
    tenantId: string;
  };
  query?: never;
  url: '/api/internal/v1/iot-manager/tenants/{tenantId}/devices';
};

export type IoTManagerInternalProvisionDeviceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * A device with the same ID already exists in Iot Hub.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerInternalProvisionDeviceError = IoTManagerInternalProvisionDeviceErrors[keyof IoTManagerInternalProvisionDeviceErrors];

export type IoTManagerInternalProvisionDeviceResponses = {
  /**
   * The device provisioning event was accepted and will be processed asynchronously.
   */
  202: unknown;
};

export type IoTManagerInternalDeleteTenantData = {
  body?: never;
  path: {
    /**
     * ID of tenant to remove.
     */
    tenantId: string;
  };
  query?: never;
  url: '/api/internal/v1/iot-manager/tenants/{tenantId}';
};

export type IoTManagerInternalDeleteTenantErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerInternalDeleteTenantError = IoTManagerInternalDeleteTenantErrors[keyof IoTManagerInternalDeleteTenantErrors];

export type IoTManagerInternalDeleteTenantResponses = {
  /**
   * The removal of tenant data was successful.
   */
  204: void;
};

export type IoTManagerInternalDeleteTenantResponse = IoTManagerInternalDeleteTenantResponses[keyof IoTManagerInternalDeleteTenantResponses];

export type IoTManagerInternalDecommissionDeviceData = {
  body?: never;
  path: {
    /**
     * ID of tenant the device belongs to.
     */
    tenantId: string;
    /**
     * ID of the target device.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/internal/v1/iot-manager/tenants/{tenantId}/devices/{deviceId}';
};

export type IoTManagerInternalDecommissionDeviceErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerInternalDecommissionDeviceError = IoTManagerInternalDecommissionDeviceErrors[keyof IoTManagerInternalDecommissionDeviceErrors];

export type IoTManagerInternalDecommissionDeviceResponses = {
  /**
   * The device decomissioning event was accepted and will be processed asynchronously.
   */
  202: unknown;
};

export type IoTManagerInternalUpdateDeviceStatusesData = {
  /**
   * List of devices to update. Up to 100 devices can be processed per request.
   */
  body: Array<{
    /**
     * Device ID.
     */
    id: string;
  }>;
  path: {
    /**
     * ID of tenant the device belongs to.
     */
    tenantId: string;
    /**
     * The status of the device
     */
    status: 'accepted' | 'noauth' | 'pending' | 'preauthorized' | 'rejected';
  };
  query?: never;
  url: '/api/internal/v1/iot-manager/tenants/{tenantId}/bulk/devices/status/{status}';
};

export type IoTManagerInternalUpdateDeviceStatusesErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerInternalUpdateDeviceStatusesError = IoTManagerInternalUpdateDeviceStatusesErrors[keyof IoTManagerInternalUpdateDeviceStatusesErrors];

export type IoTManagerInternalUpdateDeviceStatusesResponses = {
  /**
   * The device status update bulk event was accepted and will be processed asynchronously.
   */
  202: unknown;
};

export type IoTManagerManagementListIntegrationsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Page number.
     */
    page?: number;
    /**
     * Number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v1/iot-manager/integrations';
};

export type IoTManagerManagementListIntegrationsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerManagementListIntegrationsError = IoTManagerManagementListIntegrationsErrors[keyof IoTManagerManagementListIntegrationsErrors];

export type IoTManagerManagementListIntegrationsResponses = {
  /**
   * OK. Returns list of integrations.
   */
  200: Array<Integration>;
};

export type IoTManagerManagementListIntegrationsResponse = IoTManagerManagementListIntegrationsResponses[keyof IoTManagerManagementListIntegrationsResponses];

export type IoTManagerManagementRegisterIntegrationData = {
  body: Integration;
  path?: never;
  query?: never;
  url: '/api/management/v1/iot-manager/integrations';
};

export type IoTManagerManagementRegisterIntegrationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerManagementRegisterIntegrationError = IoTManagerManagementRegisterIntegrationErrors[keyof IoTManagerManagementRegisterIntegrationErrors];

export type IoTManagerManagementRegisterIntegrationResponses = {
  /**
   * URL of the newly registered integration. Please note that the inventory webhook scope is supported in plans equal or above professional.
   */
  201: unknown;
};

export type IoTManagerManagementRemoveIntegrationData = {
  body?: never;
  path: {
    /**
     * Integration identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/iot-manager/integrations/{id}';
};

export type IoTManagerManagementRemoveIntegrationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerManagementRemoveIntegrationError = IoTManagerManagementRemoveIntegrationErrors[keyof IoTManagerManagementRemoveIntegrationErrors];

export type IoTManagerManagementRemoveIntegrationResponses = {
  /**
   * Integration unregistered successfully.
   */
  204: void;
};

export type IoTManagerManagementRemoveIntegrationResponse =
  IoTManagerManagementRemoveIntegrationResponses[keyof IoTManagerManagementRemoveIntegrationResponses];

export type IoTManagerManagementSetIntegrationCredentialsData = {
  body: Credentials;
  path: {
    /**
     * Integration identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/iot-manager/integrations/{id}/credentials';
};

export type IoTManagerManagementSetIntegrationCredentialsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerManagementSetIntegrationCredentialsError =
  IoTManagerManagementSetIntegrationCredentialsErrors[keyof IoTManagerManagementSetIntegrationCredentialsErrors];

export type IoTManagerManagementSetIntegrationCredentialsResponses = {
  /**
   * Credentials updated successfully.
   */
  204: void;
};

export type IoTManagerManagementSetIntegrationCredentialsResponse =
  IoTManagerManagementSetIntegrationCredentialsResponses[keyof IoTManagerManagementSetIntegrationCredentialsResponses];

export type IoTManagerManagementUnregisterDeviceIntegrationsData = {
  body?: never;
  path: {
    /**
     * The unique ID of the device.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/management/v1/iot-manager/devices/{deviceId}';
};

export type IoTManagerManagementUnregisterDeviceIntegrationsErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerManagementUnregisterDeviceIntegrationsError =
  IoTManagerManagementUnregisterDeviceIntegrationsErrors[keyof IoTManagerManagementUnregisterDeviceIntegrationsErrors];

export type IoTManagerManagementUnregisterDeviceIntegrationsResponses = {
  /**
   * OK. Device successfully unregistered.
   */
  204: DeviceState;
};

export type IoTManagerManagementUnregisterDeviceIntegrationsResponse =
  IoTManagerManagementUnregisterDeviceIntegrationsResponses[keyof IoTManagerManagementUnregisterDeviceIntegrationsResponses];

export type IoTManagerManagementGetDeviceStatesData = {
  body?: never;
  path: {
    /**
     * The unique ID of the device.
     */
    deviceId: string;
  };
  query?: never;
  url: '/api/management/v1/iot-manager/devices/{deviceId}/state';
};

export type IoTManagerManagementGetDeviceStatesErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerManagementGetDeviceStatesError = IoTManagerManagementGetDeviceStatesErrors[keyof IoTManagerManagementGetDeviceStatesErrors];

export type IoTManagerManagementGetDeviceStatesResponses = {
  /**
   * Mapping from integration ID to DeviceState objects for all applicable integrations.
   */
  200: {
    [key: string]: DeviceState;
  };
};

export type IoTManagerManagementGetDeviceStatesResponse = IoTManagerManagementGetDeviceStatesResponses[keyof IoTManagerManagementGetDeviceStatesResponses];

export type IoTManagerManagementGetDeviceStateData = {
  body?: never;
  path: {
    /**
     * The unique ID of the device.
     */
    deviceId: string;
    /**
     * The unique ID of the integration.
     */
    integrationId: string;
  };
  query?: never;
  url: '/api/management/v1/iot-manager/devices/{deviceId}/state/{integrationId}';
};

export type IoTManagerManagementGetDeviceStateErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerManagementGetDeviceStateError = IoTManagerManagementGetDeviceStateErrors[keyof IoTManagerManagementGetDeviceStateErrors];

export type IoTManagerManagementGetDeviceStateResponses = {
  /**
   * OK. Returns device reported and desired state for the integration.
   */
  200: DeviceState;
};

export type IoTManagerManagementGetDeviceStateResponse = IoTManagerManagementGetDeviceStateResponses[keyof IoTManagerManagementGetDeviceStateResponses];

export type IoTManagerManagementReplaceStateData = {
  body: DeviceState;
  path: {
    /**
     * The unique ID of the device.
     */
    deviceId: string;
    /**
     * The unique ID of the integration.
     */
    integrationId: string;
  };
  query?: never;
  url: '/api/management/v1/iot-manager/devices/{deviceId}/state/{integrationId}';
};

export type IoTManagerManagementReplaceStateErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Conflict.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerManagementReplaceStateError = IoTManagerManagementReplaceStateErrors[keyof IoTManagerManagementReplaceStateErrors];

export type IoTManagerManagementReplaceStateResponses = {
  /**
   * OK. Returns the updated device state.
   */
  200: DeviceState;
};

export type IoTManagerManagementReplaceStateResponse = IoTManagerManagementReplaceStateResponses[keyof IoTManagerManagementReplaceStateResponses];

export type IoTManagerManagementListEventsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Page number.
     */
    page?: number;
    /**
     * Number of results per page.
     */
    per_page?: number;
    /**
     * The unique ID of the integration to get the events from.
     */
    integration_id?: string;
  };
  url: '/api/management/v1/iot-manager/events';
};

export type IoTManagerManagementListEventsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user is not permitted to access the resource.
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IoTManagerManagementListEventsError = IoTManagerManagementListEventsErrors[keyof IoTManagerManagementListEventsErrors];

export type IoTManagerManagementListEventsResponses = {
  /**
   * OK. Returns list of events.
   */
  200: Array<Event>;
};

export type IoTManagerManagementListEventsResponse = IoTManagerManagementListEventsResponses[keyof IoTManagerManagementListEventsResponses];

export type CheckLivelinessData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/tenantadm/alive';
};

export type CheckLivelinessErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CheckLivelinessError = CheckLivelinessErrors[keyof CheckLivelinessErrors];

export type CheckLivelinessResponses = {
  /**
   * Service is up and running
   *
   */
  204: void;
};

export type CheckLivelinessResponse = CheckLivelinessResponses[keyof CheckLivelinessResponses];

export type TenantadmInternalCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/tenantadm/health';
};

export type TenantadmInternalCheckHealthErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
  /**
   * Service unhealthy / not ready to accept traffic. At least one dependency is not running.
   *
   */
  503: _Error;
};

export type TenantadmInternalCheckHealthError = TenantadmInternalCheckHealthErrors[keyof TenantadmInternalCheckHealthErrors];

export type TenantadmInternalCheckHealthResponses = {
  /**
   * Service is healthy and all dependencies are up and running.
   *
   */
  204: void;
};

export type TenantadmInternalCheckHealthResponse = TenantadmInternalCheckHealthResponses[keyof TenantadmInternalCheckHealthResponses];

export type ListTenantsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Tenant ID filter. Matches if the tenant ID is equal to this string.
     *
     */
    id?: string;
    /**
     * Tenant plan. Matches if the tenant plan is equal to this string.
     *
     */
    plan?: string;
    /**
     * Matches if the tenant account is a trial account.
     *
     */
    trial?: boolean;
    /**
     * Tenant filter. Matches if the tenant ID is equal to this string, or tenant's name or tenant's admin username contain this string.
     *
     */
    q?: string;
    /**
     * List children tenants belonging to the given tenant ID.
     *
     */
    parent_tenant_id?: string;
    /**
     * If specified, the response will include tenant objects with field matching this string.
     * You can specify multiple fields by setting field parameter multiple times in one query.
     *
     */
    field?: Array<string>;
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/internal/v1/tenantadm/tenants';
};

export type ListTenantsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListTenantsError = ListTenantsErrors[keyof ListTenantsErrors];

export type ListTenantsResponses = {
  /**
   * ListOfTenants
   *
   * Successful response.
   */
  200: Array<Tenant>;
};

export type ListTenantsResponse = ListTenantsResponses[keyof ListTenantsResponses];

export type VerifyTenantTokenData = {
  body?: never;
  headers: {
    /**
     * The tenant token in base64-encoded form.
     */
    Authorization: string;
  };
  path?: never;
  query?: never;
  url: '/api/internal/v1/tenantadm/tenants/verify';
};

export type VerifyTenantTokenErrors = {
  /**
   * Verification failed.
   */
  401: unknown;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type VerifyTenantTokenError = VerifyTenantTokenErrors[keyof VerifyTenantTokenErrors];

export type VerifyTenantTokenResponses = {
  /**
   * The token is valid. A tenant descriptor is returned.
   */
  200: Tenant;
};

export type VerifyTenantTokenResponse = VerifyTenantTokenResponses[keyof VerifyTenantTokenResponses];

export type SetAccountStatusData = {
  /**
   * Target suspension status
   */
  body: TenantStatus;
  path: {
    /**
     * Tenant ID.
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/tenantadm/tenants/{id}/status';
};

export type SetAccountStatusErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type SetAccountStatusError = SetAccountStatusErrors[keyof SetAccountStatusErrors];

export type SetAccountStatusResponses = {
  /**
   * The tenant was successfully (un)suspended.
   *
   */
  200: unknown;
};

export type TenantadmInternalDeleteTenantData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/tenantadm/tenants/{tenant_id}';
};

export type TenantadmInternalDeleteTenantErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type TenantadmInternalDeleteTenantError = TenantadmInternalDeleteTenantErrors[keyof TenantadmInternalDeleteTenantErrors];

export type TenantadmInternalDeleteTenantResponses = {
  /**
   * All the tenant data removed.
   */
  204: void;
};

export type TenantadmInternalDeleteTenantResponse = TenantadmInternalDeleteTenantResponses[keyof TenantadmInternalDeleteTenantResponses];

export type ShowTenantData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: {
    /**
     * Boolean flag to include children tenants, if included will result in another db call quering all the tenants with parent tenant id set to the tenant in question.
     */
    include_children?: boolean;
  };
  url: '/api/internal/v1/tenantadm/tenants/{tenant_id}';
};

export type ShowTenantErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowTenantError = ShowTenantErrors[keyof ShowTenantErrors];

export type ShowTenantResponses = {
  /**
   * A tenant descriptor is returned.
   */
  200: Tenant;
};

export type ShowTenantResponse = ShowTenantResponses[keyof ShowTenantResponses];

export type UpdateTenantData = {
  /**
   * Updated tenant data.
   */
  body: TenantUpdateInternal;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/tenantadm/tenants/{tenant_id}';
};

export type UpdateTenantErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * The tenant cannot be updated becaues of a conflict.
   *
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateTenantError = UpdateTenantErrors[keyof UpdateTenantErrors];

export type UpdateTenantResponses = {
  /**
   * Tenant information updated.
   */
  204: void;
};

export type UpdateTenantResponse = UpdateTenantResponses[keyof UpdateTenantResponses];

export type DeleteTenantChildrenData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/tenantadm/tenants/{tenant_id}/children';
};

export type DeleteTenantChildrenErrors = {
  /**
   * The specified tenant is not a Service Provider.
   *
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteTenantChildrenError = DeleteTenantChildrenErrors[keyof DeleteTenantChildrenErrors];

export type DeleteTenantChildrenResponses = {
  /**
   * All the tenant data removed.
   */
  204: void;
};

export type DeleteTenantChildrenResponse = DeleteTenantChildrenResponses[keyof DeleteTenantChildrenResponses];

export type AssignTenantsToServiceProviderData = {
  /**
   * The unique identifiers of the tenants to be assigned.
   */
  body: {
    tenant_ids?: Array<string>;
  };
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/tenantadm/tenants/{tenant_id}/children';
};

export type AssignTenantsToServiceProviderErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * The specified tenant is not a Service Provider.
   *
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AssignTenantsToServiceProviderError = AssignTenantsToServiceProviderErrors[keyof AssignTenantsToServiceProviderErrors];

export type AssignTenantsToServiceProviderResponses = {
  /**
   * Tenant successfully assigned to service provider.
   */
  204: void;
};

export type AssignTenantsToServiceProviderResponse = AssignTenantsToServiceProviderResponses[keyof AssignTenantsToServiceProviderResponses];

export type DeleteParentReferenceData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
    /**
     * Child ID.
     */
    child_id: string;
  };
  query?: never;
  url: '/api/internal/v1/tenantadm/tenants/{tenant_id}/children/{child_id}';
};

export type DeleteParentReferenceErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteParentReferenceError = DeleteParentReferenceErrors[keyof DeleteParentReferenceErrors];

export type DeleteParentReferenceResponses = {
  /**
   * The parent reference is removed.
   */
  204: void;
};

export type DeleteParentReferenceResponse = DeleteParentReferenceResponses[keyof DeleteParentReferenceResponses];

export type TenantInfoData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/tenantadm/user/tenant';
};

export type TenantInfoErrors = {
  /**
   * Verification failed.
   */
  401: unknown;
  /**
   * User is not a part of any tenant organization.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type TenantInfoError = TenantInfoErrors[keyof TenantInfoErrors];

export type TenantInfoResponses = {
  /**
   * A tenant descriptor is returned.
   */
  200: Tenant;
};

export type TenantInfoResponse = TenantInfoResponses[keyof TenantInfoResponses];

export type GetBillingInformationData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/billing';
};

export type GetBillingInformationErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetBillingInformationError = GetBillingInformationErrors[keyof GetBillingInformationErrors];

export type GetBillingInformationResponses = {
  /**
   * Stripe stored card data is returned.
   */
  200: BillingInfo;
};

export type GetBillingInformationResponse = GetBillingInformationResponses[keyof GetBillingInformationResponses];

export type InitCardUpdateData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/billing/card';
};

export type InitCardUpdateErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Tenant is in invalid state; see error for details.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InitCardUpdateError = InitCardUpdateErrors[keyof InitCardUpdateErrors];

export type InitCardUpdateResponses = {
  /**
   * Stripe setup intent id and secret is returned.
   */
  200: CardSetupData;
};

export type InitCardUpdateResponse = InitCardUpdateResponses[keyof InitCardUpdateResponses];

export type ConfirmCardUpdateData = {
  body?: never;
  path: {
    /**
     * Setup intent ID obtained from POST /card.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/tenantadm/billing/card/{id}/confirm';
};

export type ConfirmCardUpdateErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Setup intent is in invalid state; see error for details.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ConfirmCardUpdateError = ConfirmCardUpdateErrors[keyof ConfirmCardUpdateErrors];

export type ConfirmCardUpdateResponses = {
  /**
   * New credit card is saved as the default one.
   */
  204: void;
};

export type ConfirmCardUpdateResponse = ConfirmCardUpdateResponses[keyof ConfirmCardUpdateResponses];

export type GetBillingProfileData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/billing/profile';
};

export type GetBillingProfileErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetBillingProfileError = GetBillingProfileErrors[keyof GetBillingProfileErrors];

export type GetBillingProfileResponses = {
  /**
   * The billing information for the account.
   */
  200: BillingProfile;
};

export type GetBillingProfileResponse = GetBillingProfileResponses[keyof GetBillingProfileResponses];

export type UpdateBillingProfileData = {
  /**
   * The updated billing information.
   */
  body: BillingProfileUpdate;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/billing/profile';
};

export type UpdateBillingProfileErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Payload too large
   */
  413: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateBillingProfileError = UpdateBillingProfileErrors[keyof UpdateBillingProfileErrors];

export type UpdateBillingProfileResponses = {
  /**
   * The updated billing information.
   */
  200: BillingProfile;
};

export type UpdateBillingProfileResponse = UpdateBillingProfileResponses[keyof UpdateBillingProfileResponses];

export type RegisterBillingProfileData = {
  /**
   * The billing profile.
   */
  body: BillingProfile;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/billing/profile';
};

export type RegisterBillingProfileErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Payload too large
   */
  413: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type RegisterBillingProfileError = RegisterBillingProfileErrors[keyof RegisterBillingProfileErrors];

export type RegisterBillingProfileResponses = {
  /**
   * Billing profile registered successfully.
   */
  200: BillingProfile;
};

export type RegisterBillingProfileResponse = RegisterBillingProfileResponses[keyof RegisterBillingProfileResponses];

export type ShowSubscriptionData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/billing/subscription';
};

export type ShowSubscriptionErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Forbidden
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowSubscriptionError = ShowSubscriptionErrors[keyof ShowSubscriptionErrors];

export type ShowSubscriptionResponses = {
  /**
   * OK
   */
  200: Subscription;
};

export type ShowSubscriptionResponse = ShowSubscriptionResponses[keyof ShowSubscriptionResponses];

export type ChangeSubscriptionData = {
  /**
   * Subscription change request
   */
  body: SubscriptionRequest;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/billing/subscription';
};

export type ChangeSubscriptionErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Forbidden
   */
  403: unknown;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * billing for your account is not self-managed: please contact support
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ChangeSubscriptionError = ChangeSubscriptionErrors[keyof ChangeSubscriptionErrors];

export type ChangeSubscriptionResponses = {
  /**
   * Request accepted and scheduled for processing
   */
  202: unknown;
};

export type PreviewInvoiceData = {
  /**
   * Subscription preview request
   */
  body: PreviewRequest;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/billing/subscription/invoices/preview';
};

export type PreviewInvoiceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Forbidden
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * No invoice could be generated
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type PreviewInvoiceError = PreviewInvoiceErrors[keyof PreviewInvoiceErrors];

export type PreviewInvoiceResponses = {
  /**
   * Successfully rendered the preview.
   */
  200: Invoice;
};

export type PreviewInvoiceResponse = PreviewInvoiceResponses[keyof PreviewInvoiceResponses];

export type GetStripeSecretData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/billing/secret';
};

export type GetStripeSecretErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetStripeSecretError = GetStripeSecretErrors[keyof GetStripeSecretErrors];

export type GetStripeSecretResponses = {
  /**
   * Stripe client secret is returned.
   */
  200: CheckoutData;
};

export type GetStripeSecretResponse = GetStripeSecretResponses[keyof GetStripeSecretResponses];

export type ContactSupportData = {
  /**
   * Support request data
   */
  body: SupportRequest;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/contact/support';
};

export type ContactSupportErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ContactSupportError = ContactSupportErrors[keyof ContactSupportErrors];

export type ContactSupportResponses = {
  /**
   * Message accepted.
   */
  202: unknown;
};

export type ListTenantsV2Data = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v2/tenantadm/tenants';
};

export type ListTenantsV2Errors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListTenantsV2Error = ListTenantsV2Errors[keyof ListTenantsV2Errors];

export type ListTenantsV2Responses = {
  /**
   * ListOfTenants
   *
   * List of tenants is returned
   */
  200: Array<Tenant>;
};

export type ListTenantsV2Response = ListTenantsV2Responses[keyof ListTenantsV2Responses];

export type CreateNewTenantData = {
  /**
   * New Tenant
   */
  body: NewTenant;
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/tenants';
};

export type CreateNewTenantErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Forbidden because the current tenant is not a service provider.
   *
   */
  403: _Error;
  /**
   * Tenant or admin user is duplicated.
   *
   */
  409: _Error;
  /**
   * Tenant limit for max child tenants exhausted.
   *
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreateNewTenantError = CreateNewTenantErrors[keyof CreateNewTenantErrors];

export type CreateNewTenantResponses = {
  /**
   * Request to create tenant was accepted
   */
  202: unknown;
};

export type SignUpData = {
  body: {
    /**
     * Organization name (ASCII characters only, max 100 characters)
     */
    organization: string;
    /**
     * Email address (ASCII characters only)
     */
    email: string;
    /**
     * Password
     */
    password: string;
    /**
     * reCAPTCHA response
     */
    'g-recaptcha-response': string;
    /**
     * customer name
     */
    name?: string;
    subscription_type?: 'trial' | 'azure';
    /**
     * Subscription token is used to resolve the externally managed
     * subscription. The token is required if subscription_type is "azure".
     */
    subscription_token?: string;
    /**
     * Campaign
     */
    campaign?: string;
    /**
     * captcha timestamp
     */
    ts?: number;
  };
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/tenants/signup';
};

export type SignUpErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Recaptcha verififaction failed.
   *
   */
  401: _Error;
  /**
   * Endpoint disabled.
   *
   */
  405: _Error;
  /**
   * Email is duplicated.
   *
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type SignUpError = SignUpErrors[keyof SignUpErrors];

export type SignUpResponses = {
  /**
   * Request to create organization was accepted
   */
  202: unknown;
};

export type CreateTrialAccountData = {
  body: {
    /**
     * Organization name (ASCII characters only, max 100 characters)
     */
    organization: string;
    /**
     * Email address (ASCII characters only)
     */
    email: string;
    /**
     * Password
     */
    password: string;
    /**
     * reCAPTCHA response
     */
    'g-recaptcha-response': string;
    /**
     * customer name
     */
    name?: string;
    /**
     * customer plan
     */
    plan?: 'os' | 'professional' | 'enterprise';
    /**
     * Campaign
     */
    campaign?: string;
    /**
     * captcha timestamp
     */
    ts?: number;
  };
  path?: never;
  query?: never;
  url: '/api/management/v2/tenantadm/tenants/trial';
};

export type CreateTrialAccountErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Recaptcha verififaction failed.
   *
   */
  401: _Error;
  /**
   * Endpoint disabled.
   *
   */
  405: _Error;
  /**
   * Email is duplicated.
   *
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreateTrialAccountError = CreateTrialAccountErrors[keyof CreateTrialAccountErrors];

export type CreateTrialAccountResponses = {
  /**
   * Request to create organization was accepted
   */
  202: unknown;
};

export type DeleteInactiveAccountData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/tenantadm/tenants/{id}';
};

export type DeleteInactiveAccountErrors = {
  /**
   * User token does not provide access to tenant with given Id.
   *
   */
  403: _Error;
  /**
   * The tenant cannot be removed.
   * Only inactive tenant can be removed.
   *
   */
  405: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteInactiveAccountError = DeleteInactiveAccountErrors[keyof DeleteInactiveAccountErrors];

export type DeleteInactiveAccountResponses = {
  /**
   * Tenant removed.
   */
  204: void;
};

export type DeleteInactiveAccountResponse = DeleteInactiveAccountResponses[keyof DeleteInactiveAccountResponses];

export type CancelAccountData = {
  /**
   * Cancellation request
   */
  body: CancelRequest;
  path: {
    /**
     * Tenant ID.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/tenantadm/tenants/{id}/cancel';
};

export type CancelAccountErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * User token does not provide access to tenant with given Id.
   *
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * The tenant is not active.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CancelAccountError = CancelAccountErrors[keyof CancelAccountErrors];

export type CancelAccountResponses = {
  /**
   * Request has been successfully recorded.
   *
   */
  202: unknown;
};

export type UpdateChildTenantData = {
  /**
   * Updated Tenant
   */
  body: UpdateChildTenant;
  path: {
    /**
     * Tenant ID.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/tenantadm/tenants/{id}/child';
};

export type UpdateChildTenantErrors = {
  /**
   * User token does not provide access to tenant with given Id.
   *
   */
  403: _Error;
  /**
   * Device limit for children tenants exhausted.
   *
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateChildTenantError = UpdateChildTenantErrors[keyof UpdateChildTenantErrors];

export type UpdateChildTenantResponses = {
  /**
   * Tenant updated.
   */
  204: void;
};

export type UpdateChildTenantResponse = UpdateChildTenantResponses[keyof UpdateChildTenantResponses];

export type UpdatePlanData = {
  /**
   * Plan change request
   */
  body: PlanChangeRequest;
  path: {
    /**
     * Tenant ID.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/tenantadm/tenants/{id}/plan';
};

export type UpdatePlanErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * User token does not provide access to tenant with given Id.
   *
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * The tenant is not active.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdatePlanError = UpdatePlanErrors[keyof UpdatePlanErrors];

export type UpdatePlanResponses = {
  /**
   * Request has been successfully recorded.
   *
   */
  202: unknown;
};

export type InitTenantRemovalData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/tenantadm/tenants/{id}/remove/start';
};

export type InitTenantRemovalErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * User token does not provide access to tenant with given Id.
   *
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InitTenantRemovalError = InitTenantRemovalErrors[keyof InitTenantRemovalErrors];

export type InitTenantRemovalResponses = {
  /**
   * Request to cancel the tenant upgrade was accepted
   */
  202: unknown;
};

export type ActivateAccountData = {
  /**
   * Target suspension status
   */
  body: TenantStatus;
  path: {
    /**
     * Tenant ID.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/tenantadm/tenants/{id}/status';
};

export type ActivateAccountErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * User token does not provide access to tenant with given Id.
   *
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * The tenant was suspended.
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ActivateAccountError = ActivateAccountErrors[keyof ActivateAccountErrors];

export type ActivateAccountResponses = {
  /**
   * Request to activate tenant was accepted.
   *
   */
  202: unknown;
};

export type UseradmCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/useradm/health';
};

export type UseradmCheckHealthErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
  /**
   * Service unhealthy / not ready to accept traffic. At least one dependency is not running.
   *
   */
  503: _Error;
};

export type UseradmCheckHealthError = UseradmCheckHealthErrors[keyof UseradmCheckHealthErrors];

export type UseradmCheckHealthResponses = {
  /**
   * Service is healthy and all dependencies are up and running.
   *
   */
  204: void;
};

export type UseradmCheckHealthResponse = UseradmCheckHealthResponses[keyof UseradmCheckHealthResponses];

export type UseradmCheckLivelinessData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/internal/v1/useradm/alive';
};

export type UseradmCheckLivelinessErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UseradmCheckLivelinessError = UseradmCheckLivelinessErrors[keyof UseradmCheckLivelinessErrors];

export type UseradmCheckLivelinessResponses = {
  /**
   * Service is up and running.
   */
  204: void;
};

export type UseradmCheckLivelinessResponse = UseradmCheckLivelinessResponses[keyof UseradmCheckLivelinessResponses];

export type VerifyJwtData = {
  body?: never;
  headers: {
    /**
     * The token in base64-encoded form.
     */
    Authorization: string;
    /**
     * URI the original request was sent to, the URI is expected to have
     * at least 4 components, eg. /api/management/1.0/foo/bar
     *
     */
    'X-Forwarded-Uri': string;
    /**
     * HTTP method used when accessing the original URI
     */
    'X-Forwarded-Method': 'GET' | 'PUT' | 'POST' | 'DELETE';
  };
  path?: never;
  query?: never;
  url: '/api/internal/v1/useradm/auth/verify';
};

export type VerifyJwtErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Verification failed, authentication should not be granted.
   */
  401: _Error;
  /**
   * Token has expired - apply for a new one.
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type VerifyJwtError = VerifyJwtErrors[keyof VerifyJwtErrors];

export type VerifyJwtResponses = {
  /**
   * The token is valid.
   */
  200: unknown;
};

export type ListAllUsersData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Results page number
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
    /**
     * Limit result by user ID, can be repeated to include multiple users in the query.
     *
     */
    id?: string;
    /**
     * Limit result by tenant ID.
     *
     */
    tenant_id?: string;
    /**
     * Limit result by user email, can be repeated to include multiple users in the query.
     *
     */
    email?: string;
    /**
     * Filter by SSO provider ID. Must be a UUID or on the form oauth2/<provider>.
     *
     */
    sso_provider_id?: string;
    /**
     * Filter by SSO subject ID.
     *
     */
    sso_subject?: string;
    /**
     * Filter users created after timestamp (UNIX timestamp).
     *
     */
    created_after?: number;
    /**
     * Filter users created before timestamp (UNIX timestamp).
     *
     */
    created_before?: number;
    /**
     * Filter users updated after timestamp (UNIX timestamp).
     *
     */
    updated_after?: number;
    /**
     * Filter users updated before timestamp (UNIX timestamp).
     *
     */
    updated_before?: number;
  };
  url: '/api/internal/v1/useradm/users';
};

export type ListAllUsersErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListAllUsersError = ListAllUsersErrors[keyof ListAllUsersErrors];

export type ListAllUsersResponses = {
  /**
   * ListOfUsers
   *
   * Successful response.
   */
  200: Array<UserWithTenantInfo>;
};

export type ListAllUsersResponse = ListAllUsersResponses[keyof ListAllUsersResponses];

export type UseradmCreateTenantData = {
  body: TenantNew;
  path?: never;
  query?: never;
  url: '/api/internal/v1/useradm/tenants';
};

export type UseradmCreateTenantErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UseradmCreateTenantError = UseradmCreateTenantErrors[keyof UseradmCreateTenantErrors];

export type UseradmCreateTenantResponses = {
  /**
   * The tenant was created successfully.
   */
  201: unknown;
};

export type AssignTenantSsoData = {
  /**
   * Existing tenant ID to get the SSO configuration from.
   */
  body: TenantNew;
  path: {
    /**
     * Tenant ID to asign the SSO to.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/sso/assign';
};

export type AssignTenantSsoErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AssignTenantSsoError = AssignTenantSsoErrors[keyof AssignTenantSsoErrors];

export type AssignTenantSsoResponses = {
  /**
   * The SSO data was successfuly assigned, however there is additional message returned (for instance in case of replacement of existing configuration).
   */
  200: unknown;
  /**
   * The SSO data was successfuly assigned.
   */
  201: unknown;
};

export type UseradmInternalDeleteTenantDataData = {
  body?: never;
  path: {
    /**
     * Tenant ID to delete.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}';
};

export type UseradmInternalDeleteTenantDataErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UseradmInternalDeleteTenantDataError = UseradmInternalDeleteTenantDataErrors[keyof UseradmInternalDeleteTenantDataErrors];

export type UseradmInternalDeleteTenantDataResponses = {
  /**
   * The tenant data was successfully deleted.
   */
  204: void;
};

export type UseradmInternalDeleteTenantDataResponse = UseradmInternalDeleteTenantDataResponses[keyof UseradmInternalDeleteTenantDataResponses];

export type ListUsersInternalData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: {
    /**
     * Limit result by user ID, can be repeated to include multiple users in the query.
     *
     */
    id?: string;
    /**
     * Limit result by user email, can be repeated to include multiple users in the query.
     *
     */
    email?: string;
    /**
     * Filter users created after timestamp (UNIX timestamp).
     *
     */
    created_after?: number;
    /**
     * Filter users created before timestamp (UNIX timestamp).
     *
     */
    created_before?: number;
    /**
     * Filter users updated after timestamp (UNIX timestamp).
     *
     */
    updated_after?: number;
    /**
     * Filter users updated before timestamp (UNIX timestamp).
     *
     */
    updated_before?: number;
  };
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/users';
};

export type ListUsersInternalErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListUsersInternalError = ListUsersInternalErrors[keyof ListUsersInternalErrors];

export type ListUsersInternalResponses = {
  /**
   * ListOfUsers
   *
   * Successful response.
   */
  200: Array<User>;
};

export type ListUsersInternalResponse = ListUsersInternalResponses[keyof ListUsersInternalResponses];

export type CreateUserInternalData = {
  /**
   * New user data.
   */
  body: UserNewInternal;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/users';
};

export type CreateUserInternalErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * User name or ID is duplicated, or limit on maximum number of users has been exceeded.
   *
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreateUserInternalError = CreateUserInternalErrors[keyof CreateUserInternalErrors];

export type CreateUserInternalResponses = {
  /**
   * The user was successfully created.
   */
  201: unknown;
};

export type ListUsersEmailAddressesData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
    /**
     * Device ID.
     */
    device_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/devices/{device_id}/users';
};

export type ListUsersEmailAddressesErrors = {
  /**
   * Device id not provided.
   *
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListUsersEmailAddressesError = ListUsersEmailAddressesErrors[keyof ListUsersEmailAddressesErrors];

export type ListUsersEmailAddressesResponses = {
  /**
   * Successful response.
   */
  200: Emails;
};

export type ListUsersEmailAddressesResponse = ListUsersEmailAddressesResponses[keyof ListUsersEmailAddressesResponses];

export type DeleteUserInternalData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
    /**
     * User ID.
     */
    user_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/users/{user_id}';
};

export type DeleteUserInternalErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteUserInternalError = DeleteUserInternalErrors[keyof DeleteUserInternalErrors];

export type DeleteUserInternalResponses = {
  /**
   * User deleted.
   */
  204: void;
};

export type DeleteUserInternalResponse = DeleteUserInternalResponses[keyof DeleteUserInternalResponses];

export type RevokeUserTokensData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
    /**
     * User ID.
     */
    user_id?: string;
  };
  url: '/api/internal/v1/useradm/tokens';
};

export type RevokeUserTokensErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type RevokeUserTokensError = RevokeUserTokensErrors[keyof RevokeUserTokensErrors];

export type RevokeUserTokensResponses = {
  /**
   * Tokens deleted.
   */
  204: void;
};

export type RevokeUserTokensResponse = RevokeUserTokensResponses[keyof RevokeUserTokensResponses];

export type ClearTenantLimitsData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/limits';
};

export type ClearTenantLimitsErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ClearTenantLimitsError = ClearTenantLimitsErrors[keyof ClearTenantLimitsErrors];

export type ClearTenantLimitsResponses = {
  /**
   * Limits information deleted.
   */
  204: void;
};

export type ClearTenantLimitsResponse = ClearTenantLimitsResponses[keyof ClearTenantLimitsResponses];

export type GetTenantLimitsInternalData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/limits';
};

export type GetTenantLimitsInternalErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetTenantLimitsInternalError = GetTenantLimitsInternalErrors[keyof GetTenantLimitsInternalErrors];

export type GetTenantLimitsInternalResponses = {
  /**
   * Successful response.
   */
  200: Limits;
};

export type GetTenantLimitsInternalResponse = GetTenantLimitsInternalResponses[keyof GetTenantLimitsInternalResponses];

export type UpdateTenantLimitsData = {
  body: Limits;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/limits';
};

export type UpdateTenantLimitsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateTenantLimitsError = UpdateTenantLimitsErrors[keyof UpdateTenantLimitsErrors];

export type UpdateTenantLimitsResponses = {
  /**
   * Limit information updated.
   */
  204: void;
};

export type UpdateTenantLimitsResponse = UpdateTenantLimitsResponses[keyof UpdateTenantLimitsResponses];

export type ShowTenantPlanAndLimitsData = {
  body?: never;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/plan_binding';
};

export type ShowTenantPlanAndLimitsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowTenantPlanAndLimitsError = ShowTenantPlanAndLimitsErrors[keyof ShowTenantPlanAndLimitsErrors];

export type ShowTenantPlanAndLimitsResponses = {
  /**
   * Successful response - a plan information is returned.
   */
  200: PlanBindingDetails;
};

export type ShowTenantPlanAndLimitsResponse = ShowTenantPlanAndLimitsResponses[keyof ShowTenantPlanAndLimitsResponses];

export type UpdateTenantPlanAndLimitsData = {
  body: PlanBinding;
  path: {
    /**
     * Tenant ID.
     */
    tenant_id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/tenants/{tenant_id}/plan_binding';
};

export type UpdateTenantPlanAndLimitsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateTenantPlanAndLimitsError = UpdateTenantPlanAndLimitsErrors[keyof UpdateTenantPlanAndLimitsErrors];

export type UpdateTenantPlanAndLimitsResponses = {
  /**
   * Plan and limits information updated.
   */
  204: void;
};

export type UpdateTenantPlanAndLimitsResponse = UpdateTenantPlanAndLimitsResponses[keyof UpdateTenantPlanAndLimitsResponses];

export type AssignTenantsInternalData = {
  /**
   * tenantIdsData.
   */
  body: TenantIdsData;
  path: {
    /**
     * User id or email to assign.
     */
    id: string;
  };
  query?: never;
  url: '/api/internal/v1/useradm/users/{id}/assign';
};

export type AssignTenantsInternalErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AssignTenantsInternalError = AssignTenantsInternalErrors[keyof AssignTenantsInternalErrors];

export type AssignTenantsInternalResponses = {
  /**
   * User assigned.
   */
  200: unknown;
};

export type LoginData = {
  /**
   * Log in options
   */
  body?: LoginOptions;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/auth/login';
};

export type LoginErrors = {
  /**
   * Bad request, see error message for details.
   */
  400: _Error;
  /**
   * The user is not authorized. There are two possible scenarios for that:
   * * username/password do not match
   * * token for two factor authentication (if enabled) was not correct
   *
   */
  401: _Error;
  /**
   * Feature not available in your Plan.
   */
  403: _Error;
  /**
   * Internal server error.
   */
  500: _Error;
};

export type LoginError = LoginErrors[keyof LoginErrors];

export type LoginResponses = {
  /**
   * Authentication successful - a new JWT is issued and returned with content type application/jwt.
   * The JWT is signed with the API's private key ('RS256' signing algorithm), and contains the following standard claims:
   * * 'iss' - issuer
   * * 'exp' - expiry date
   * * 'sub' - unique, autogenerated user ID
   * * 'scp' - 'mender.*', allows access to all APIs/methods.
   *
   * If the login process requires SSO, the content type will be application/json and the body will contain a JSON document containing the following properties:
   * * 'id' - the SSO integration ID
   * * 'kind' - the SSO kind, e.g., 'sso/saml' or 'sso/oidc'
   *
   * Example response: {"id": "1a97b53f-9b84-5048-8874-df01f4f58f78", "kind": "sso/saml"}
   *
   */
  200: string;
};

export type LoginResponse = LoginResponses[keyof LoginResponses];

export type LoginUsingAMagicLinkData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/auth/magic/{id}';
};

export type LoginUsingAMagicLinkErrors = {
  /**
   * The user is not authorized. There are two possible scenarios for that:
   * * the user may not have been initialized successfully
   * * the tenant may not have been initialized successfully
   *
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type LoginUsingAMagicLinkError = LoginUsingAMagicLinkErrors[keyof LoginUsingAMagicLinkErrors];

export type SubmitAssertionDataData = {
  body: {
    /**
     * Base64 encoded XML assertion data.
     *
     */
    SAMLResponse: string;
  };
  path: {
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/auth/sso/{id}/acs';
};

export type SubmitAssertionDataErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Request forbidden, possibly due to the feature not being available in the current Mender plan.
   *
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Endpoint does not support the provided Content-Type.
   *
   */
  415: _Error;
  /**
   * The metadata has not been uploaded yet.
   *
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type SubmitAssertionDataError = SubmitAssertionDataErrors[keyof SubmitAssertionDataErrors];

export type LoginViaGivenIdentityProviderData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/auth/sso/{id}/login';
};

export type LoginViaGivenIdentityProviderErrors = {
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * The metadata has not been uploaded yet.
   *
   */
  422: _Error;
};

export type LoginViaGivenIdentityProviderError = LoginViaGivenIdentityProviderErrors[keyof LoginViaGivenIdentityProviderErrors];

export type LogoutData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/auth/logout';
};

export type LogoutErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type LogoutError = LogoutErrors[keyof LogoutErrors];

export type LogoutResponses = {
  /**
   * Request has been accepted and the JWT token has been invalidated.
   *
   */
  202: unknown;
};

export type InitiatePasswordResetRequestData = {
  /**
   * Password Reset request, it includes the email address of the user.
   *
   */
  body?: PasswordResetRequest;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/auth/password-reset/start';
};

export type InitiatePasswordResetRequestErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Too many requests.
   *
   */
  429: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InitiatePasswordResetRequestError = InitiatePasswordResetRequestErrors[keyof InitiatePasswordResetRequestErrors];

export type InitiatePasswordResetRequestResponses = {
  /**
   * The request has been accepted.
   */
  202: unknown;
};

export type CompletePasswordResetRequestData = {
  /**
   * Password Reset request, it includes the secret hash received by email, as well as the new password of the user.
   *
   */
  body?: PasswordResetCompletion;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/auth/password-reset/complete';
};

export type CompletePasswordResetRequestErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CompletePasswordResetRequestError = CompletePasswordResetRequestErrors[keyof CompletePasswordResetRequestErrors];

export type CompletePasswordResetRequestResponses = {
  /**
   * The request has been accepted.
   */
  202: unknown;
};

export type InitiateEmailVerificationRequestData = {
  /**
   * Email Verification request, it includes the email address of the user.
   *
   */
  body?: EmailVerificationRequest;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/auth/verify-email/start';
};

export type InitiateEmailVerificationRequestErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type InitiateEmailVerificationRequestError = InitiateEmailVerificationRequestErrors[keyof InitiateEmailVerificationRequestErrors];

export type InitiateEmailVerificationRequestResponses = {
  /**
   * The request has been accepted.
   */
  202: unknown;
};

export type CompleteEmailVerificationData = {
  /**
   * Email Verification request, it includes the secret hash received by email.
   *
   */
  body?: EmailVerificationCompletion;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/auth/verify-email/complete';
};

export type CompleteEmailVerificationErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CompleteEmailVerificationError = CompleteEmailVerificationErrors[keyof CompleteEmailVerificationErrors];

export type CompleteEmailVerificationResponses = {
  /**
   * The email address has been verified.
   */
  204: void;
};

export type CompleteEmailVerificationResponse = CompleteEmailVerificationResponses[keyof CompleteEmailVerificationResponses];

export type VerifyPlanData = {
  body?: never;
  headers: {
    /**
     * Required minimal plan to complete the request
     *
     */
    'X-Mender-Required-Minimal-Plan': string;
    /**
     * Required add-on to complete the request
     *
     */
    'X-Mender-Required-Addon': string;
  };
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/auth/plan-verify';
};

export type VerifyPlanErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The required minimal plan doesn't match the user plan
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type VerifyPlanError = VerifyPlanErrors[keyof VerifyPlanErrors];

export type VerifyPlanResponses = {
  /**
   * The required minimal plan matches the user plan
   */
  202: unknown;
};

export type LoginOAuth20Data = {
  body?: never;
  path: {
    /**
     * Provider ID
     */
    provider: 'github' | 'google' | 'microsoft';
  };
  query?: never;
  url: '/api/management/v1/useradm/oauth2/{provider}';
};

export type LoginOAuth20Errors = {
  /**
   * The required OAuth 2.0 provider is not available.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type LoginOAuth20Error = LoginOAuth20Errors[keyof LoginOAuth20Errors];

export type ListUsersManagementData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Limit result by user ID, can be repeated to include multiple users in the query.
     *
     */
    id?: string;
    /**
     * Limit result by user email, can be repeated to include multiple users in the query.
     *
     */
    email?: string;
    /**
     * Filter users created after timestamp (UNIX timestamp).
     *
     */
    created_after?: number;
    /**
     * Filter users created before timestamp (UNIX timestamp).
     *
     */
    created_before?: number;
    /**
     * Filter users updated after timestamp (UNIX timestamp).
     *
     */
    updated_after?: number;
    /**
     * Filter users updated before timestamp (UNIX timestamp).
     *
     */
    updated_before?: number;
  };
  url: '/api/management/v1/useradm/users';
};

export type ListUsersManagementErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListUsersManagementError = ListUsersManagementErrors[keyof ListUsersManagementErrors];

export type ListUsersManagementResponses = {
  /**
   * ListOfUsers
   *
   * Successful response.
   */
  200: Array<User>;
};

export type ListUsersManagementResponse = ListUsersManagementResponses[keyof ListUsersManagementResponses];

export type CreateUserManagementData = {
  /**
   * New user data.
   */
  body: UserNew;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/users';
};

export type CreateUserManagementErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The email address is duplicated, password is too short, current password doesn't match or limit on maximum number of users has been exceeded.
   * It is possible that the user with the given email address exists
   * in a different organization. In this case Mender server will
   * also produce an error because the email address has to be unique
   * across all organizations.
   *
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreateUserManagementError = CreateUserManagementErrors[keyof CreateUserManagementErrors];

export type CreateUserManagementResponses = {
  /**
   * The user was successfully created.
   */
  201: unknown;
};

export type CheckUserExistenceData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Email address to check.
     */
    email: string;
  };
  url: '/api/management/v1/useradm/users/exists';
};

export type CheckUserExistenceErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Forbidden.
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CheckUserExistenceError = CheckUserExistenceErrors[keyof CheckUserExistenceErrors];

export type CheckUserExistenceResponses = {
  /**
   * Successful response - returns a JSON containing a boolean 'exists'.
   */
  200: {
    /**
     * True if the user exists.
     */
    exists?: boolean;
  };
};

export type CheckUserExistenceResponse = CheckUserExistenceResponses[keyof CheckUserExistenceResponses];

export type RemoveUserData = {
  body?: never;
  path: {
    /**
     * User id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/users/{id}';
};

export type RemoveUserErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type RemoveUserError = RemoveUserErrors[keyof RemoveUserErrors];

export type RemoveUserResponses = {
  /**
   * User removed.
   */
  204: void;
};

export type RemoveUserResponse = RemoveUserResponses[keyof RemoveUserResponses];

export type ShowUserData = {
  body?: never;
  path: {
    /**
     * User id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/users/{id}';
};

export type ShowUserErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowUserError = ShowUserErrors[keyof ShowUserErrors];

export type ShowUserResponses = {
  /**
   * Successful response - a user information is returned.
   */
  200: User;
};

export type ShowUserResponse = ShowUserResponses[keyof ShowUserResponses];

export type UpdateUserData = {
  /**
   * Updated user data.
   */
  body: UserUpdate;
  path: {
    /**
     * User id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/users/{id}';
};

export type UpdateUserErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * The email address is duplicated, the password is too short
   * or the user is trying to modify another user's password.
   *
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];

export type UpdateUserResponses = {
  /**
   * User information updated.
   */
  204: void;
};

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export type ShowOwnUserDataData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/users/me';
};

export type ShowOwnUserDataErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowOwnUserDataError = ShowOwnUserDataErrors[keyof ShowOwnUserDataErrors];

export type ShowOwnUserDataResponses = {
  /**
   * Successful response - a user information is returned.
   */
  200: UserWithTenantInfo;
};

export type ShowOwnUserDataResponse = ShowOwnUserDataResponses[keyof ShowOwnUserDataResponses];

export type UpdateOwnUserDataData = {
  /**
   * Updated user data.
   */
  body: OwnUserUpdate;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/users/me';
};

export type UpdateOwnUserDataErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * The email address is duplicated or the password is too short.
   *
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateOwnUserDataError = UpdateOwnUserDataErrors[keyof UpdateOwnUserDataErrors];

export type UpdateOwnUserDataResponses = {
  /**
   * User information updated.
   */
  204: void;
};

export type UpdateOwnUserDataResponse = UpdateOwnUserDataResponses[keyof UpdateOwnUserDataResponses];

export type Enable2FaData = {
  body?: never;
  path: {
    /**
     * User id (use 'me' for authenticated user).
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/users/{id}/2fa/enable';
};

export type Enable2FaErrors = {
  /**
   * Operation is invalid, see error message.
   *
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Forbidden.
   */
  403: _Error;
  /**
   * The user was not found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type Enable2FaError = Enable2FaErrors[keyof Enable2FaErrors];

export type Enable2FaResponses = {
  /**
   * 2FA is enabled.
   */
  200: unknown;
};

export type Disable2FaData = {
  body?: never;
  path: {
    /**
     * User id (use 'me' for authenticated user).
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/users/{id}/2fa/disable';
};

export type Disable2FaErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Forbidden.
   */
  403: _Error;
  /**
   * The user was not found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type Disable2FaError = Disable2FaErrors[keyof Disable2FaErrors];

export type Disable2FaResponses = {
  /**
   * 2FA is disabled.
   */
  200: unknown;
};

export type AssignTenantsData = {
  /**
   * tenantIdsData.
   */
  body: TenantIdsData;
  path: {
    /**
     * User id or email to assign.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/users/{id}/assign';
};

export type AssignTenantsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Forbidden.
   */
  403: _Error;
  /**
   * The user was not found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type AssignTenantsError = AssignTenantsErrors[keyof AssignTenantsErrors];

export type AssignTenantsResponses = {
  /**
   * User assigned.
   */
  200: unknown;
};

export type ListRolesV1Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/roles';
};

export type ListRolesV1Errors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListRolesV1Error = ListRolesV1Errors[keyof ListRolesV1Errors];

export type ListRolesV1Responses = {
  /**
   * ListOfRoles
   *
   * Successful response.
   */
  200: Array<RoleV1>;
};

export type ListRolesV1Response = ListRolesV1Responses[keyof ListRolesV1Responses];

export type CreateRoleV1Data = {
  /**
   * New role data.
   */
  body: RoleV1;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/roles';
};

export type CreateRoleV1Errors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreateRoleV1Error = CreateRoleV1Errors[keyof CreateRoleV1Errors];

export type CreateRoleV1Responses = {
  /**
   * The role was successfully created.
   */
  201: unknown;
};

export type DeleteRoleV1Data = {
  body?: never;
  path: {
    /**
     * Role id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/roles/{id}';
};

export type DeleteRoleV1Errors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteRoleV1Error = DeleteRoleV1Errors[keyof DeleteRoleV1Errors];

export type DeleteRoleV1Responses = {
  /**
   * Role removed.
   */
  204: void;
};

export type DeleteRoleV1Response = DeleteRoleV1Responses[keyof DeleteRoleV1Responses];

export type ShowRoleV1Data = {
  body?: never;
  path: {
    /**
     * Role id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/roles/{id}';
};

export type ShowRoleV1Errors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The role was not found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowRoleV1Error = ShowRoleV1Errors[keyof ShowRoleV1Errors];

export type ShowRoleV1Responses = {
  /**
   * Successful response - a role information is returned.
   */
  200: RoleV1;
};

export type ShowRoleV1Response = ShowRoleV1Responses[keyof ShowRoleV1Responses];

export type UpdateRoleV1Data = {
  /**
   * Updated role data.
   */
  body: RoleV1;
  path: {
    /**
     * Role id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/roles/{id}';
};

export type UpdateRoleV1Errors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The role does not exist.
   *
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateRoleV1Error = UpdateRoleV1Errors[keyof UpdateRoleV1Errors];

export type UpdateRoleV1Responses = {
  /**
   * Role information updated.
   */
  202: unknown;
};

export type ShowUserSettingsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/settings';
};

export type ShowUserSettingsErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowUserSettingsError = ShowUserSettingsErrors[keyof ShowUserSettingsErrors];

export type ShowUserSettingsResponses = {
  /**
   * Successful response - a user information is returned.
   */
  200: Settings;
};

export type ShowUserSettingsResponse = ShowUserSettingsResponses[keyof ShowUserSettingsResponses];

export type UpdateUserSettingsData = {
  /**
   * New user settings.
   */
  body: Settings;
  headers?: {
    /**
     * Contains the settings' current ETag, and performs the update only if it matches the one stored in the database.
     */
    'If-Match'?: string;
  };
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/settings';
};

export type UpdateUserSettingsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The user has no access to authentication settings because of unverified email address.
   *
   */
  403: _Error;
  /**
   * ETag doesn't match.
   */
  412: unknown;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateUserSettingsError = UpdateUserSettingsErrors[keyof UpdateUserSettingsErrors];

export type UpdateUserSettingsResponses = {
  /**
   * User settings set.
   */
  201: unknown;
};

export type ShowMyUserSettingsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/settings/me';
};

export type ShowMyUserSettingsErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowMyUserSettingsError = ShowMyUserSettingsErrors[keyof ShowMyUserSettingsErrors];

export type ShowMyUserSettingsResponses = {
  /**
   * Successful response - a user information is returned.
   */
  200: Settings;
};

export type ShowMyUserSettingsResponse = ShowMyUserSettingsResponses[keyof ShowMyUserSettingsResponses];

export type UpdateMyUserSettingsData = {
  /**
   * New user settings.
   */
  body: Settings;
  headers?: {
    /**
     * Contains the settings' current ETag, and performs the update only if it matches the one stored in the database.
     */
    'If-Match'?: string;
  };
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/settings/me';
};

export type UpdateMyUserSettingsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * ETag doesn't match.
   */
  412: unknown;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateMyUserSettingsError = UpdateMyUserSettingsErrors[keyof UpdateMyUserSettingsErrors];

export type UpdateMyUserSettingsResponses = {
  /**
   * User settings set.
   */
  201: unknown;
};

export type Get2FaQrCodeData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/2faqr';
};

export type Get2FaQrCodeErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type Get2FaQrCodeError = Get2FaQrCodeErrors[keyof Get2FaQrCodeErrors];

export type Get2FaQrCodeResponses = {
  /**
   * Successful response - a user information is returned.
   */
  200: {
    /**
     * The content of the QR code.
     */
    qr?: string;
  };
};

export type Get2FaQrCodeResponse = Get2FaQrCodeResponses[keyof Get2FaQrCodeResponses];

export type VerifyThe2FaTokenData = {
  /**
   * The token
   */
  body: {
    /**
     * The 2FA token to verify.
     */
    token2fa?: string;
  };
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/2faverify';
};

export type VerifyThe2FaTokenErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * The verification failed.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type VerifyThe2FaTokenError = VerifyThe2FaTokenErrors[keyof VerifyThe2FaTokenErrors];

export type VerifyThe2FaTokenResponses = {
  /**
   * Successful response - the verification was successful.
   */
  202: unknown;
};

export type ListUserPersonalAccessTokensData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/settings/tokens';
};

export type ListUserPersonalAccessTokensErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListUserPersonalAccessTokensError = ListUserPersonalAccessTokensErrors[keyof ListUserPersonalAccessTokensErrors];

export type ListUserPersonalAccessTokensResponses = {
  /**
   * ListOfTokens
   *
   * Endpoint returns a list of tokens.
   */
  200: Array<PersonalAccessToken>;
};

export type ListUserPersonalAccessTokensResponse = ListUserPersonalAccessTokensResponses[keyof ListUserPersonalAccessTokensResponses];

export type CreatePersonalAccessTokenData = {
  /**
   * The token object.
   */
  body: PersonalAccessTokenRequest;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/settings/tokens';
};

export type CreatePersonalAccessTokenErrors = {
  /**
   * The request body is malformed or expiration time is too big.
   *
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Personal Access Token with the same name already exists.
   *
   */
  409: _Error;
  /**
   * Maximum number of Personal Acess Tokens reached for this user.
   *
   */
  422: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreatePersonalAccessTokenError = CreatePersonalAccessTokenErrors[keyof CreatePersonalAccessTokenErrors];

export type CreatePersonalAccessTokenResponses = {
  /**
   * Token has been created.
   */
  200: string;
};

export type CreatePersonalAccessTokenResponse = CreatePersonalAccessTokenResponses[keyof CreatePersonalAccessTokenResponses];

export type RevokePersonalAccessTokenData = {
  body?: never;
  path: {
    /**
     * Token identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/settings/tokens/{id}';
};

export type RevokePersonalAccessTokenErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type RevokePersonalAccessTokenError = RevokePersonalAccessTokenErrors[keyof RevokePersonalAccessTokenErrors];

export type RevokePersonalAccessTokenResponses = {
  /**
   * Token removed.
   */
  204: void;
};

export type RevokePersonalAccessTokenResponse = RevokePersonalAccessTokenResponses[keyof RevokePersonalAccessTokenResponses];

export type DeleteSamlOrOpenIdConnectMetadataData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/sso/idp/metadata/{id}';
};

export type DeleteSamlOrOpenIdConnectMetadataErrors = {
  /**
   * Request forbidden, possibly due to feature not being available in current Mender plan.
   *
   */
  403: _Error;
  /**
   * Metadata with the given id was not found.
   *
   */
  404: _Error;
  /**
   * The tenant is managed by a Service Provider and the configuration cannot be changed.
   *
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteSamlOrOpenIdConnectMetadataError = DeleteSamlOrOpenIdConnectMetadataErrors[keyof DeleteSamlOrOpenIdConnectMetadataErrors];

export type DeleteSamlOrOpenIdConnectMetadataResponses = {
  /**
   * Request to delete the metadata was accepted
   */
  204: void;
};

export type DeleteSamlOrOpenIdConnectMetadataResponse = DeleteSamlOrOpenIdConnectMetadataResponses[keyof DeleteSamlOrOpenIdConnectMetadataResponses];

export type GetIdpSamlOrOpenIdConnectMetadataForTheTenantData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/sso/idp/metadata/{id}';
};

export type GetIdpSamlOrOpenIdConnectMetadataForTheTenantErrors = {
  /**
   * Request forbidden, possibly due to feature not being available in current Mender plan.
   *
   */
  403: _Error;
  /**
   * There is nothing to return under the given id
   *
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetIdpSamlOrOpenIdConnectMetadataForTheTenantError =
  GetIdpSamlOrOpenIdConnectMetadataForTheTenantErrors[keyof GetIdpSamlOrOpenIdConnectMetadataForTheTenantErrors];

export type GetIdpSamlOrOpenIdConnectMetadataForTheTenantResponses = {
  /**
   * IdentityProviderMetadata
   *
   * Identity Provider Metadata retrieved successfully.
   */
  200: string;
};

export type GetIdpSamlOrOpenIdConnectMetadataForTheTenantResponse =
  GetIdpSamlOrOpenIdConnectMetadataForTheTenantResponses[keyof GetIdpSamlOrOpenIdConnectMetadataForTheTenantResponses];

export type UpdateSamlMetadataData = {
  body: string;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/sso/idp/metadata/{id}';
};

export type UpdateSamlMetadataErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Request forbidden, possibly due to feature not being available in current Mender plan.
   *
   */
  403: _Error;
  /**
   * Given id was not associated with any Metadata object.
   *
   */
  404: _Error;
  /**
   * The tenant is managed by a Service Provider and the configuration cannot be changed.
   *
   */
  409: _Error;
  /**
   * Endpoint does not support the Content-Type provided.
   *
   */
  415: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateSamlMetadataError = UpdateSamlMetadataErrors[keyof UpdateSamlMetadataErrors];

export type UpdateSamlMetadataResponses = {
  /**
   * SAML Metadata updated successfully.
   */
  204: void;
};

export type UpdateSamlMetadataResponse = UpdateSamlMetadataResponses[keyof UpdateSamlMetadataResponses];

export type GetSamlOrOpenIdConnectMetadataForTheTenantData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/sso/idp/metadata';
};

export type GetSamlOrOpenIdConnectMetadataForTheTenantErrors = {
  /**
   * Request forbidden, possibly due to feature not being available in current Mender plan.
   *
   */
  403: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetSamlOrOpenIdConnectMetadataForTheTenantError =
  GetSamlOrOpenIdConnectMetadataForTheTenantErrors[keyof GetSamlOrOpenIdConnectMetadataForTheTenantErrors];

export type GetSamlOrOpenIdConnectMetadataForTheTenantResponses = {
  /**
   * ListOfMetadata
   *
   * SAML or OpenID Connect Metadata retrieved successfully.
   */
  200: Array<SamlMetadata>;
};

export type GetSamlOrOpenIdConnectMetadataForTheTenantResponse =
  GetSamlOrOpenIdConnectMetadataForTheTenantResponses[keyof GetSamlOrOpenIdConnectMetadataForTheTenantResponses];

export type PostSamlOpenIdConnectMetadataOrUrlPointToThemData = {
  body: string;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/sso/idp/metadata';
};

export type PostSamlOpenIdConnectMetadataOrUrlPointToThemErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Request forbidden, possibly due to feature not being available in current Mender plan.
   *
   */
  403: _Error;
  /**
   * The tenant is managed by a Service Provider and the configuration cannot be changed.
   *
   */
  409: _Error;
  /**
   * Entity was too large to process.
   *
   */
  413: _Error;
  /**
   * Endpoint does not support the Content-Type provided.
   *
   */
  415: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type PostSamlOpenIdConnectMetadataOrUrlPointToThemError =
  PostSamlOpenIdConnectMetadataOrUrlPointToThemErrors[keyof PostSamlOpenIdConnectMetadataOrUrlPointToThemErrors];

export type PostSamlOpenIdConnectMetadataOrUrlPointToThemResponses = {
  /**
   * SAML or OpenID Connect Metadata stored successfully.
   */
  201: unknown;
};

export type GetServiceProviderMetadataByIdData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/sso/sp/metadata/{id}';
};

export type GetServiceProviderMetadataByIdErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Request forbidden, possibly due to feature not being available in current Mender plan.
   *
   */
  403: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetServiceProviderMetadataByIdError = GetServiceProviderMetadataByIdErrors[keyof GetServiceProviderMetadataByIdErrors];

export type GetServiceProviderMetadataByIdResponses = {
  /**
   * ServiceProviderMetadata
   *
   * Service Provider Metadata retrieved successfully.
   */
  200: string;
  /**
   * SAML or OpenID Connect Metadata was empty.
   */
  204: void;
};

export type GetServiceProviderMetadataByIdResponse = GetServiceProviderMetadataByIdResponses[keyof GetServiceProviderMetadataByIdResponses];

export type GetTenantLimitsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/limits';
};

export type GetTenantLimitsErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetTenantLimitsError = GetTenantLimitsErrors[keyof GetTenantLimitsErrors];

export type GetTenantLimitsResponses = {
  /**
   * Usage statistics and limits.
   */
  200: Limits;
};

export type GetTenantLimitsResponse = GetTenantLimitsResponses[keyof GetTenantLimitsResponses];

export type ListPlansData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Starting page.
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v1/useradm/plans';
};

export type ListPlansErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListPlansError = ListPlansErrors[keyof ListPlansErrors];

export type ListPlansResponses = {
  /**
   * Successful response - list of plans is returned.
   */
  200: Array<Plan>;
};

export type ListPlansResponse = ListPlansResponses[keyof ListPlansResponses];

export type ShowPlanAndLimitsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/management/v1/useradm/plan_binding';
};

export type ShowPlanAndLimitsErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowPlanAndLimitsError = ShowPlanAndLimitsErrors[keyof ShowPlanAndLimitsErrors];

export type ShowPlanAndLimitsResponses = {
  /**
   * Successful response - a plan information is returned.
   */
  200: PlanBindingDetails;
};

export type ShowPlanAndLimitsResponse = ShowPlanAndLimitsResponses[keyof ShowPlanAndLimitsResponses];

export type IssueTokenData = {
  body?: never;
  path: {
    /**
     * Tenant identifier.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v1/useradm/users/tenants/{id}/token';
};

export type IssueTokenErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type IssueTokenError = IssueTokenErrors[keyof IssueTokenErrors];

export type IssueTokenResponses = {
  /**
   * Token has been created and returned.
   */
  200: string;
};

export type IssueTokenResponse = IssueTokenResponses[keyof IssueTokenResponses];

export type ListRolesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Results page number
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v2/useradm/roles';
};

export type ListRolesErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListRolesError = ListRolesErrors[keyof ListRolesErrors];

export type ListRolesResponses = {
  /**
   * ListOfRoles
   *
   * Successful response.
   */
  200: Array<Role>;
};

export type ListRolesResponse = ListRolesResponses[keyof ListRolesResponses];

export type CreateRoleData = {
  /**
   * New role data.
   */
  body: Role;
  path?: never;
  query?: never;
  url: '/api/management/v2/useradm/roles';
};

export type CreateRoleErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The role with the same name already exists.
   *
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreateRoleError = CreateRoleErrors[keyof CreateRoleErrors];

export type CreateRoleResponses = {
  /**
   * The role was successfully created.
   */
  201: unknown;
};

export type DeleteRoleData = {
  body?: never;
  path: {
    /**
     * Role id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/useradm/roles/{id}';
};

export type DeleteRoleErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteRoleError = DeleteRoleErrors[keyof DeleteRoleErrors];

export type DeleteRoleResponses = {
  /**
   * Role removed.
   */
  204: void;
};

export type DeleteRoleResponse = DeleteRoleResponses[keyof DeleteRoleResponses];

export type ShowRoleData = {
  body?: never;
  path: {
    /**
     * Role id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/useradm/roles/{id}';
};

export type ShowRoleErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ShowRoleError = ShowRoleErrors[keyof ShowRoleErrors];

export type ShowRoleResponses = {
  /**
   * Successful response - a role information is returned.
   */
  200: Role;
};

export type ShowRoleResponse = ShowRoleResponses[keyof ShowRoleResponses];

export type UpdateRoleData = {
  /**
   * Updated role data.
   */
  body: Role;
  path: {
    /**
     * Role id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/useradm/roles/{id}';
};

export type UpdateRoleErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The role does not exist.
   *
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdateRoleError = UpdateRoleErrors[keyof UpdateRoleErrors];

export type UpdateRoleResponses = {
  /**
   * Role information updated.
   */
  200: unknown;
};

export type ListPermissionSetsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Results page number
     */
    page?: number;
    /**
     * Maximum number of results per page.
     */
    per_page?: number;
  };
  url: '/api/management/v2/useradm/permission_sets';
};

export type ListPermissionSetsErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type ListPermissionSetsError = ListPermissionSetsErrors[keyof ListPermissionSetsErrors];

export type ListPermissionSetsResponses = {
  /**
   * ListOfPermissionSets
   *
   * Successful response.
   */
  200: Array<PermissionSet>;
};

export type ListPermissionSetsResponse = ListPermissionSetsResponses[keyof ListPermissionSetsResponses];

export type CreatePermissionSetData = {
  /**
   * New permission set data.
   */
  body: PermissionSet;
  path?: never;
  query?: never;
  url: '/api/management/v2/useradm/permission_sets';
};

export type CreatePermissionSetErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The permission set with the same name already exists..
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type CreatePermissionSetError = CreatePermissionSetErrors[keyof CreatePermissionSetErrors];

export type CreatePermissionSetResponses = {
  /**
   * The permission set was successfully created.
   */
  201: unknown;
};

export type DeletePermissionSetData = {
  body?: never;
  path: {
    /**
     * Permission set id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/useradm/permission_sets/{id}';
};

export type DeletePermissionSetErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeletePermissionSetError = DeletePermissionSetErrors[keyof DeletePermissionSetErrors];

export type DeletePermissionSetResponses = {
  /**
   * Permission set removed.
   */
  204: void;
};

export type DeletePermissionSetResponse = DeletePermissionSetResponses[keyof DeletePermissionSetResponses];

export type GetPermissionSetData = {
  body?: never;
  path: {
    /**
     * Permission set id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/useradm/permission_sets/{id}';
};

export type GetPermissionSetErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Not Found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type GetPermissionSetError = GetPermissionSetErrors[keyof GetPermissionSetErrors];

export type GetPermissionSetResponses = {
  /**
   * Successful response - a permission set information is returned.
   */
  200: PermissionSet;
};

export type GetPermissionSetResponse = GetPermissionSetResponses[keyof GetPermissionSetResponses];

export type UpdatePermissionSetData = {
  /**
   * Updated permission set data.
   */
  body: PermissionSet;
  path: {
    /**
     * Permission set id.
     */
    id: string;
  };
  query?: never;
  url: '/api/management/v2/useradm/permission_sets/{id}';
};

export type UpdatePermissionSetErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * The permission set was not found.
   */
  404: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UpdatePermissionSetError = UpdatePermissionSetErrors[keyof UpdatePermissionSetErrors];

export type UpdatePermissionSetResponses = {
  /**
   * Permission Set information updated.
   */
  200: unknown;
};

export type UserFeedbackData = {
  /**
   * User feedback form.
   *
   */
  body: FeedbackProduct | FeedbackAi;
  path: {
    /**
     * The form identifier
     */
    form_id: 'product' | 'feat.ai';
  };
  query?: never;
  url: '/api/management/v2/useradm/support/feedback/{form_id}';
};

export type UserFeedbackErrors = {
  /**
   * Unauthorized.
   */
  401: _Error;
  /**
   * Response already recorded
   */
  409: _Error;
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type UserFeedbackError = UserFeedbackErrors[keyof UserFeedbackErrors];

export type UserFeedbackResponses = {
  /**
   * Response recorded
   */
  204: void;
};

export type UserFeedbackResponse = UserFeedbackResponses[keyof UserFeedbackResponses];

export type WorkflowsCheckLivelinessData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/status';
};

export type WorkflowsCheckLivelinessErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type WorkflowsCheckLivelinessError = WorkflowsCheckLivelinessErrors[keyof WorkflowsCheckLivelinessErrors];

export type WorkflowsCheckLivelinessResponses = {
  /**
   * Successful response.
   */
  200: {
    id?: string;
    name?: string;
  };
};

export type WorkflowsCheckLivelinessResponse = WorkflowsCheckLivelinessResponses[keyof WorkflowsCheckLivelinessResponses];

export type WorkflowsCheckHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/health';
};

export type WorkflowsCheckHealthErrors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
  /**
   * Service is temporarily unavailable (currently unhealthy).
   */
  502: _Error;
};

export type WorkflowsCheckHealthError = WorkflowsCheckHealthErrors[keyof WorkflowsCheckHealthErrors];

export type WorkflowsCheckHealthResponses = {
  /**
   * Service is healthy.
   */
  204: void;
};

export type WorkflowsCheckHealthResponse = WorkflowsCheckHealthResponses[keyof WorkflowsCheckHealthResponses];

export type DeleteTenantData2Data = {
  body?: never;
  path: {
    /**
     * Tenant id to remove.
     */
    id: string;
  };
  query?: never;
  url: '/api/v1/tenants/{id}';
};

export type DeleteTenantData2Errors = {
  /**
   * Internal Server Error.
   */
  500: _Error;
};

export type DeleteTenantData2Error = DeleteTenantData2Errors[keyof DeleteTenantData2Errors];

export type DeleteTenantData2Responses = {
  /**
   * Tenant data removed
   */
  204: void;
};

export type DeleteTenantData2Response = DeleteTenantData2Responses[keyof DeleteTenantData2Responses];

export type StartWorkflowData = {
  /**
   * Contains the definition of the job to be started.
   */
  body: Array<InputParameter>;
  path: {
    /**
     * Workflow identifier.
     */
    name: string;
  };
  query?: never;
  url: '/api/v1/workflow/{name}';
};

export type StartWorkflowErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
};

export type StartWorkflowError = StartWorkflowErrors[keyof StartWorkflowErrors];

export type StartWorkflowResponses = {
  /**
   * Workflow created successfully
   */
  201: {
    id?: string;
    name?: string;
  };
};

export type StartWorkflowResponse = StartWorkflowResponses[keyof StartWorkflowResponses];

export type StartBatchWorkflowsData = {
  /**
   * Contains the definition of the job to be started.
   */
  body: Array<Array<InputParameter>>;
  path: {
    /**
     * Workflow identifier.
     */
    name: string;
  };
  query?: never;
  url: '/api/v1/workflow/{name}/batch';
};

export type StartBatchWorkflowsErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Not Found.
   */
  404: _Error;
};

export type StartBatchWorkflowsError = StartBatchWorkflowsErrors[keyof StartBatchWorkflowsErrors];

export type StartBatchWorkflowsResponses = {
  /**
   * Workflows created successfully
   */
  201: Array<{
    id?: string;
    name?: string;
    error?: string;
  }>;
};

export type StartBatchWorkflowsResponse = StartBatchWorkflowsResponses[keyof StartBatchWorkflowsResponses];

export type WorkflowStatusData = {
  body?: never;
  path: {
    /**
     * Workflow identifier.
     */
    name: string;
    /**
     * Job identifier
     */
    id: string;
  };
  query?: never;
  url: '/api/v1/workflow/{name}/{id}';
};

export type WorkflowStatusErrors = {
  /**
   * Not Found.
   */
  404: _Error;
};

export type WorkflowStatusError = WorkflowStatusErrors[keyof WorkflowStatusErrors];

export type WorkflowStatusResponses = {
  /**
   * Successful query
   */
  200: JobStatus;
};

export type WorkflowStatusResponse = WorkflowStatusResponses[keyof WorkflowStatusResponses];

export type ListWorkflowsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/v1/metadata/workflows';
};

export type ListWorkflowsResponses = {
  /**
   * Successful response
   */
  200: Array<Workflow>;
};

export type ListWorkflowsResponse = ListWorkflowsResponses[keyof ListWorkflowsResponses];

export type RegisterWorkflowData = {
  /**
   * Workflow definition.
   */
  body: Workflow;
  path?: never;
  query?: never;
  url: '/api/v1/metadata/workflows';
};

export type RegisterWorkflowErrors = {
  /**
   * Invalid Request.
   */
  400: _Error;
  /**
   * Conflict.
   */
  409: _Error;
};

export type RegisterWorkflowError = RegisterWorkflowErrors[keyof RegisterWorkflowErrors];

export type RegisterWorkflowResponses = {
  /**
   * Successful response.
   */
  201: unknown;
};

export type JobStructureData = {
  body?: never;
  path: {
    /**
     * Job identifier
     */
    id: string;
  };
  query?: never;
  url: '/api/v1/jobs/{id}';
};

export type JobStructureErrors = {
  /**
   * Not Found.
   */
  404: _Error;
};

export type JobStructureError = JobStructureErrors[keyof JobStructureErrors];

export type JobStructureResponses = {
  /**
   * Successful query
   */
  200: JobObject;
};

export type JobStructureResponse = JobStructureResponses[keyof JobStructureResponses];
